// **************************************************************************
// File       [ atpg.cpp ]
// Author     [ littleshamoo ]
// Synopsis   [ This files include most of the method of class Atpg ]
// Date       [ 2011/11/01 created  2023/01/05 last modified ]
// **************************************************************************

#include "atpg.h"
#include <algorithm>

using namespace CoreNs;

// **************************************************************************
// Function   [ Atpg::generatePatternSet ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:	The main function of class Atpg.
//
// 							description:
// 								This function generates a test pattern set based on a
// 								extracted fault list extracted from the target circuit.
// 								Activate STC/DTC depending on the pPatternProcessor's flag
// 								which is set previously in atpg_cmd.cpp based on user's
// 								script.
//
// 							arguments:
// 								[in, out] pPatternProcessor : A pointer to an empty pattern
// 								processor. It will contain the final test pattern set
// 								generated by ATPG after this function call. The test
// 								pattern set is generated based on the faults extracted from
// 								the target circuit.
//
// 								[in] pFaultListExtractor : A pointer to a fault list
// 								extractor containing the fault list extracted from the
// 								target circuit.
//
// 								[in] isMFO : A flag specifying whether the MFO mode is
// 								activated. MFO stands for multiple fault order, which is a
// 								heuristic with Multiple Fault Orderings.
// 						]
// Date       [ Ver. 1.0 started 2013/08/13	last modified 2023/01/05 ]
// **************************************************************************
void Atpg::generatePatternSet(PatternProcessor *pPatternProcessor, FaultListExtract *pFaultListExtractor, bool isMFO)
{
	Fault *pCurrentFault = NULL;
	FaultPtrList prevOrderFaultPtrList, newOrderFaultPtrList, newOrderFaultPtrListForSTC;
	setupCircuitParameter();
	pPatternProcessor->init(this->pCircuit_);

	// setting faults for running ATPG
	for (Fault *pFault : pFaultListExtractor->faultsInCircuit_)
	{
		const bool faultIsQualified = (pFault->faultState_ != Fault::DT && pFault->faultState_ != Fault::RE && pFault->faultyLine_ >= 0);
		if (faultIsQualified)
		{
			prevOrderFaultPtrList.push_back(pFault);
			newOrderFaultPtrList.push_back(pFault);
			newOrderFaultPtrListForSTC.push_back(pFault);
		}
	}

	const double faultPtrListSize = (double)(prevOrderFaultPtrList.size());
	const int halfListSize = faultPtrListSize / 2.0;
	// isMFO is always false if DTC is not turned on
	isMFO = (pPatternProcessor->dynamicCompression_ == PatternProcessor::ON) ? isMFO : false;
	const int faultListReorderTimes = isMFO ? (log2(faultPtrListSize) + 1) : 1;
	int numOfAtpgUntestableFaults = 0;
	int minNumOfFaultsLeft = INFINITE;
	// record pattern set when lower undetected fault or lower test length with same undetected fault
	std::vector<Pattern> bestTestPatternSet;
	for (int i = 0; i < faultListReorderTimes; ++i)
	{
		numOfAtpgUntestableFaults = 0;
		// no need to reorder for the first iteration
		if (i != 0)
		{
			// set up new fault list order
			newOrderFaultPtrList.assign(prevOrderFaultPtrList.begin(), prevOrderFaultPtrList.end());
			FaultPtrListIter it = newOrderFaultPtrList.begin();
			// start folding the fault list
			for (int j = 0; j < halfListSize; ++j)
			{
				newOrderFaultPtrList.insert(it, newOrderFaultPtrList.back());
				newOrderFaultPtrList.pop_back();
				++it;
			}
			// reinitialize the faults in fault list
			for (Fault *pFault : newOrderFaultPtrList)
			{
				pFault->detection_ = 0;
				pFault->faultState_ = Fault::UD;
			}

			// save the fault order for next new fault list order generation
			prevOrderFaultPtrList.assign(newOrderFaultPtrList.begin(), newOrderFaultPtrList.end());
			// save a fault list order for static test compression for this iteration
			newOrderFaultPtrListForSTC.assign(newOrderFaultPtrList.begin(), newOrderFaultPtrList.end());
		}
		pPatternProcessor->patternVector_.clear();
		pPatternProcessor->patternVector_.reserve(MAX_LIST_SIZE);

		// start ATPG
		while (!newOrderFaultPtrList.empty())
		{
			// meaning the newOrderFaultPtrList is already left with aborted fault
			if (newOrderFaultPtrList.front()->faultState_ == Fault::AB)
			{
				break;
			}

			// the fault is not popped in previous call of StuckAtFaultATPG()/TransitionDelayFaultATPG()
			// => the fault is neither aborted nor untestable => a pattern was found => detected fault
			if (pCurrentFault == newOrderFaultPtrList.front())
			{
				newOrderFaultPtrList.front()->faultState_ = Fault::DT;
				newOrderFaultPtrList.pop_front();
				continue;
			}

			pCurrentFault = newOrderFaultPtrList.front();
			const bool isTransitionDelayFault = (pCurrentFault->faultType_ == Fault::STR || pCurrentFault->faultType_ == Fault::STF);
			if (isTransitionDelayFault)
			{
				TransitionDelayFaultATPG(newOrderFaultPtrList, pPatternProcessor, numOfAtpgUntestableFaults);
			}
			else
			{
				StuckAtFaultATPG(newOrderFaultPtrList, pPatternProcessor, numOfAtpgUntestableFaults);
			}
		}
		if (pPatternProcessor->staticCompression_ == PatternProcessor::ON)
		{
			staticTestCompressionByReverseFaultSimulation(pPatternProcessor, newOrderFaultPtrListForSTC);
		}

		// finish calculation equivalent faults left
		for (Fault *pFault : newOrderFaultPtrList)
		{
			numOfAtpgUntestableFaults += pFault->equivalent_;
		}

		// better fault coverage
		if (numOfAtpgUntestableFaults < minNumOfFaultsLeft)
		{
			bestTestPatternSet = pPatternProcessor->patternVector_;
			minNumOfFaultsLeft = numOfAtpgUntestableFaults;
		}
		else if (numOfAtpgUntestableFaults == minNumOfFaultsLeft)
		{
			// less test length with same fault coverage
			if (pPatternProcessor->patternVector_.size() < bestTestPatternSet.size())
			{
				bestTestPatternSet = pPatternProcessor->patternVector_;
			}
		}
	}
	// assign the pattern set to the best one at last
	pPatternProcessor->patternVector_ = bestTestPatternSet;
}

// **************************************************************************
// Function   [ Atpg::setupCircuitParameter ]
// Commenter  [ KOREAL WWS ]
// Synopsis   [ usage:	Initialize the target circuit's parameters.
//
// 							description:
// 								This function set up all the circuits' parameters and gates'
// 								parameters. Including circuitLevel_to_eventStack.
// 						]
// Date       [ KOREAL Ver. 1.0 started 2013/08/10 last modified 2023/01/05 ]
// **************************************************************************
void Atpg::setupCircuitParameter()
{
	calculateGateDepthFromPO();
	identifyGateLineType();
	identifyGateDominator();
	identifyGateUniquePath();
}

// **************************************************************************
// Function   [ Atpg::calculateGateDepthFromPO ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:	Calculate the depthFromPo_ of each gate.
//
//              description:
// 								This functions calculates the depth (how many gates) from
// 								PO/PPO of every gates.
//
// 								This function also initializes the 
// 								this->gateID_to_valModified_,
// 								but should be moved to other places (TODO) for readability.
//            ]
// Date       [ started 2020/07/06 last modified 2023/01/05 ]
// **************************************************************************
void Atpg::calculateGateDepthFromPO()
{
	for (int gateID = this->pCircuit_->totalGate_ - 1; gateID >= 0; --gateID)
	{
		Gate &gate = this->pCircuit_->circuitGates_[gateID];
		this->gateID_to_valModified_[gateID] = 0; // sneak the initialization assignment in here

		gate.depthFromPo_ = INFINITE;
		if ((gate.gateType_ == Gate::PO) || (gate.gateType_ == Gate::PPO))
		{
			gate.depthFromPo_ = 0;
		}
		else if (gate.numFO_ > 0)
		{
			for (const int &fanOutGateID : gate.fanoutVector_)
			{
				const Gate &fanOutGate = this->pCircuit_->circuitGates_[fanOutGateID];
				if (fanOutGate.depthFromPo_ < gate.depthFromPo_)
				{
					gate.depthFromPo_ = fanOutGate.depthFromPo_ + 1;
				}
			}
		}
		// else exist no path to output, so assign depthFromPO_ to INFINITE by default
	}
}

// **************************************************************************
// Function   [ Atpg::identifyGateLineType ]
// Commenter  [ CKY WWS ]
// Synopsis   [ usage:	Identify and sets the gates' lineType
//
// 							description:
// 								This functions sets this->gateID_to_lineType_ (FREE_LINE,
// 								HEAD_LINE, BOUND_LINE). Records number of headline gates
// 								to this->numOfHeadLines_. Records all the headline gates'
// 								gateID into this->headLineGateIDs_.
//            ]
// Date       [ CKY Ver. 1.0 started 2013/08/17 last modified 2023/01/05 ]
// **************************************************************************
void Atpg::identifyGateLineType()
{
	this->numOfHeadLines_ = 0;

	for (const Gate &gate : this->pCircuit_->circuitGates_)
	{
		const int &gateID = gate.gateId_;

		this->gateID_to_lineType_[gateID] = FREE_LINE; // initialize to FREE_LINE

		if (gate.gateType_ != Gate::PI && gate.gateType_ != Gate::PPI)
		{
			for (const int &fanInGateID : gate.faninVector_)
			{
				if (this->gateID_to_lineType_[fanInGateID] != FREE_LINE)
				{
					this->gateID_to_lineType_[gateID] = BOUND_LINE;
					break;
				}
			}
		}

		// check if it is HEAD_LINE or not (rule 1)
		if ((this->gateID_to_lineType_[gateID] == FREE_LINE) && (gate.numFO_ != 1))
		{
			this->gateID_to_lineType_[gateID] = HEAD_LINE;
			++this->numOfHeadLines_;
		}

		// check if it is HEAD_LINE or not (rule 2)
		if (this->gateID_to_lineType_[gate.gateId_] == BOUND_LINE)
		{
			for (const int &fanInGateID : gate.faninVector_)
			{
				if (this->gateID_to_lineType_[fanInGateID] == FREE_LINE)
				{
					this->gateID_to_lineType_[fanInGateID] = HEAD_LINE;
					++this->numOfHeadLines_;
				}
			}
		}
	}

	// store all head lines to array this->headLineGateIDs_
	this->headLineGateIDs_.reserve(this->numOfHeadLines_);

	int count = 0;
	for (const Gate &gate : this->pCircuit_->circuitGates_)
	{
		if (this->gateID_to_lineType_[gate.gateId_] == HEAD_LINE)
		{
			this->headLineGateIDs_.push_back(gate.gateId_);
			++count;
		}
		if (count == this->numOfHeadLines_)
		{
			break;
		}
	}
}

// **************************************************************************
// Function   [ Atpg::identifyGateDominator ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:	
// 								Identify Dominator of every gate for unique sensitization.
//
// 							description:
// 								Traverse every gate and try to find each gates’ Dominator.
// 								For each gate, if it has 1 or 0 fanout gate, we can skip it
// 								because a fanout free gate's Dominator is always the same.
// 								Push its fanout gates into circuitLevel_to_eventStack. We
// 								check the event stack for levels bigger than the gate level.
// 								In the process of finding the Dominator, we keep adding
// 								the fanout gates of gates into the event stack to traverse
// 								all paths the gate would pass.(For fanout of the gate, we
// 								just need to add its Dominator.) Once the event stack has
// 								only one gate left, we say that all paths will pass this
// 								gate, so this gate is the Dominator and we push this gate
// 								in this->gateID_to_uniquePath. We also check the existence 
// 								of the Dominator in the process.
// 								The dominator doesn’t exist when:
// 									1.	Event stack isn’t empty but we find the PO/PPO in the
// 											event stack(numFO_ == 0). This implies more than one
// 										path to PO/PPO.
// 									2.	Event stack contains a fanout which has no dominator.
// 								Notice that the gateCount is equal to the number of events
// 								in the the whole event stack during this function call.
// 								If we have finished finding the Dominator of the gate,
// 								or the Dominator doesn't exist, gateCount will be 0 or
// 								set to 0. Then, we remove all the remaining events in
// 								event stack and go to next iteration(next gate).
// 								In addition, we check this->gateID_to_valModified_ to avoid
// 								repeated assignments.
// 
// 								After this function, each gate has one or zero
// 								Dominator recorded in this->gateID_to_uniquePath_.
// 								A Dominator of a gate is the wire that must be passed 
// 								for the dominated gate to reach PO/PPO.
// 
// Date       [ Ver. 1.0 started 2013/08/13  last modified 2023/01/05 ]
// **************************************************************************
void Atpg::identifyGateDominator()
{
	for (int i = this->pCircuit_->totalGate_ - 1; i >= 0; --i)
	{
		Gate &gate = this->pCircuit_->circuitGates_[i];

		if (gate.numFO_ <= 1)
		{
			continue;
		}

		int gateCount = pushGateFanoutsToEventStack(i);
		for (int j = gate.numLevel_ + 1; j < this->pCircuit_->totalLvl_; ++j)
		{
			// if next level's output isn't empty
			while (!this->circuitLevel_to_eventStack_[j].empty())
			{
				Gate &gDom = this->pCircuit_->circuitGates_[this->circuitLevel_to_eventStack_[j].top()];
				this->circuitLevel_to_eventStack_[j].pop();
				this->gateID_to_valModified_[gDom.gateId_] = 0;

				if (gateCount <= 0)
				{
					continue;
				}

				--gateCount;

				if (gateCount == 0)
				{
					// when all the fanouts of gate have been calculated
					this->gateID_to_uniquePath_[gate.gateId_].push_back(gDom.gateId_);
					break;
				}
				// If there is a gate without gates on its output, then we suppose that
				// this gate is PO/PPO. Because there are other gates still inside the
				// event queue (gateCount larger than 1), it means that the gate does
				// not have any Dominator.  Hence, we will set gateCount to zero as a
				// signal to clear the gates left in this->circuitLevel_to_eventStack_.
				// If the this->circuitLevel_to_eventStack_ is not empty but gateCount
				// is zero, we will continue.
				if (gDom.numFO_ == 0)
				{
					gateCount = 0;
				}
				else if (gDom.numFO_ > 1)
				{
					if ((int)this->gateID_to_uniquePath_[gDom.gateId_].size() == 0)
					{
						gateCount = 0;
					}
					else
					{
						// Because the first gate in this->gateID_to_uniquePath_ is
						// the closest Dominator, we just push it to event stack.
						// Then, we can skip the operation we have done
						// for gates with higher circuit level than current gate.
						Gate &gTmp = this->pCircuit_->circuitGates_[this->gateID_to_uniquePath_[gDom.gateId_][0]];
						if (!this->gateID_to_valModified_[gTmp.gateId_])
						{
							this->circuitLevel_to_eventStack_[gTmp.numLevel_].push(gTmp.gateId_);
							this->gateID_to_valModified_[gTmp.gateId_] = 1;
							++gateCount;
						}
					}
				}
				else if (!this->gateID_to_valModified_[gDom.fanoutVector_[0]])
				{
					Gate &gTmp = this->pCircuit_->circuitGates_[gDom.fanoutVector_[0]];
					this->circuitLevel_to_eventStack_[gTmp.numLevel_].push(gTmp.gateId_);
					this->gateID_to_valModified_[gTmp.gateId_] = 1;
					++gateCount;
				}
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::identifyGateUniquePath ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
// 								Compute this->gateID_to_uniquePath_(2D vector).
//                In unique path sensitization phase, we will need to know
//                if the inputs of a gate is fault reachable. Then, we can
//                prevent assigning non-controlling value to them.
//
//                We find the Dominator, then we push_back the input gate
//                which is fault reachable from the current gate.
//
//                After identifying the unique path, if a gate has Dominator,
// 								this->gateID_to_uniquePath_ of this gate will contains the
//                following gate id:
//
//                	[dominatorID fRIG1ID fRIG2ID ......]
//
// 								fRIG is faultReachableInputGate1ID for the above example
// 								Do NOT use fRIG in actual code for the sake of readability.
//
// 							description:
// 								We traverse all gates. For each gate, if it has no
// 								Dominator, we skip the gate. Now we push its fanout gates
// 								into the event stack.
// 								Notice that "count" is equal to the number of events in
// 								the whole event stack. We check the event stack for levels
// 								higher than the gate level. In this function, we keep
// 								adding the fanout of the current gate into the event stack
// 								to traverse all paths the gate would have to pass to reach
// 								PO/PPO. Simultaneously we adjust "count" and set the
// 								reachableByDominator of the fanout to current gate.
// 								Once "count" is 0 (the event stack has only one gate left),
// 								we should get the Dominator.
// 								Then we check reachableByDominator of the fanin of the
// 								Dominator. If it is the current gate, then we push the
// 								fanin into this->gateID_to_uniquePath.
// 								Finally, we go to the next iteration (the next gate).
//
//            ]
// Date       [ Ver. 1.0 started 2013/08/13  last modified 2023/01/05 ]
// **************************************************************************
void Atpg::identifyGateUniquePath()
{
	// This vector records if a gate is reachable by any dominator.
	static std::vector<int> reachableByDominator(this->pCircuit_->totalGate_);
	for (int i = this->pCircuit_->totalGate_ - 1; i >= 0; --i)
	{
		const Gate &gate = this->pCircuit_->circuitGates_[i];
		// Since we will call identifyGateDominator before this function,
		// a gate's this->gateID_to_uniquePath_ will contain one Dominator.
		// Hence, we can skip the gates while their
		// this->gateID_to_uniquePath_ is empty.
		if (this->gateID_to_uniquePath_[gate.gateId_].empty())
		{
			continue;
		}

		reachableByDominator[gate.gateId_] = i;
		int count = pushGateFanoutsToEventStack(i);
		for (int j = gate.numLevel_ + 1; j < this->pCircuit_->totalLvl_; ++j)
		{
			// condition: fanout gate was not empty
			while (!this->circuitLevel_to_eventStack_[j].empty())
			{
				Gate &gTmp = this->pCircuit_->circuitGates_[this->circuitLevel_to_eventStack_[j].top()];
				this->circuitLevel_to_eventStack_[j].pop();
				this->gateID_to_valModified_[gTmp.gateId_] = 0;
				reachableByDominator[gTmp.gateId_] = i;
				--count;
				if (count == 0)
				{
					for (int gReachID : gTmp.faninVector_)
					{
						// if it is a unique path
						if (reachableByDominator[gReachID] == i)
						{
							// save gate to this->gateID_to_uniquePath_
							this->gateID_to_uniquePath_[gate.gateId_].push_back(gReachID);
						}
					}
					break;
				}
				count += pushGateFanoutsToEventStack(gTmp.gateId_);
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::TransitionDelayFaultATPG ]
// Commenter  [ HKY CYW WWS ]
// Synopsis   [ usage: Do transition delay fault model ATPG
// 
// 							description:
// 								This function is implemented very similar to the
// 								StuckAtFaultATPG() except for the following differences.
// 								1.	The fault model used is transition delay fault instead
// 										of stuck at fault.
// 								2.	Dynamic test compression is not implemented for
// 										transition delay fault.
// 
// 							arguments:
// 								Please see the documentation of Atpg::StuckAtFaultATPG().
//            ]
// Date       [ HKY Ver. 1.0 started 2014/09/01 last modified 2023/01/05 ]
// **************************************************************************
void Atpg::TransitionDelayFaultATPG(FaultPtrList &faultPtrListForGen, PatternProcessor *pPatternProcessor, int &numOfAtpgUntestableFaults)
{
	const Fault &fTDF = *faultPtrListForGen.front();

	SINGLE_PATTERN_GENERATION_STATUS singlePatternGenerationResult = generateSinglePatternOnTargetFault(Fault(fTDF.gateID_ + this->pCircuit_->numGate_, fTDF.faultType_, fTDF.faultyLine_, fTDF.equivalent_, fTDF.faultState_), false);
	if (singlePatternGenerationResult == PATTERN_FOUND)
	{
		Pattern pattern(this->pCircuit_);
		pattern.initForTransitionDelayFault(this->pCircuit_);
		pPatternProcessor->patternVector_.push_back(pattern);
		writeAtpgValToPatternPI(pPatternProcessor->patternVector_.back());

		if ((pPatternProcessor->staticCompression_ == PatternProcessor::OFF) && (pPatternProcessor->XFill_ == PatternProcessor::ON))
		{
			randomFill(pPatternProcessor->patternVector_.back());
		}

		this->pSimulator_->parallelFaultFaultSimWithOnePattern(pPatternProcessor->patternVector_.back(), faultPtrListForGen);
		this->pSimulator_->goodSim();
		writeGoodSimValToPatternPO(pPatternProcessor->patternVector_.back());
	}
	else if (singlePatternGenerationResult == FAULT_UNTESTABLE)
	{
		faultPtrListForGen.front()->faultState_ = Fault::AU;
		numOfAtpgUntestableFaults += faultPtrListForGen.front()->equivalent_;
		faultPtrListForGen.pop_front();
	}
	else
	{
		faultPtrListForGen.front()->faultState_ = Fault::AB;
		faultPtrListForGen.push_back(faultPtrListForGen.front());
		faultPtrListForGen.pop_front();
	}
}

// **************************************************************************
// Function   [ Atpg::StuckAtFaultATPG ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage: 
// 								Do stuck at fault model ATPG on one fault and do DTC
// 								on the pattern generated to the single fault if the DTC
// 								flag is set to ON.
//
// 							description:
// 								The first fault pointed to by the first pointer in
// 								faultPtrListForGen will be selected as the first target
// 								fault for single pattern generation in this function.
// 								There will be three possible scenario after the
// 								single pattern generation on the first selected fault.
// 								1.	PATTERN_FOUND
// 										If a pattern is found for the first selected fault.
// 										A pattern will be allocated and push back to
// 										pPatternProcessor->patternVector and will be updated
// 										immediately. If the DTC is set to ON for the pattern
// 										processor. The first selected fault will immediately
// 										be dropped by fault simulation.
// 										Then the DTC stage will start officially and select
// 										other undetected faults one by one for DTC. If the
// 										latter selected fault can be detected by filling
// 										some of the X(s) to 1 or 0. The fault state of the
// 										fault will be set to DT(detected) and the pattern will
// 										be updated to the original pattern with specific X(s)
// 										assigned.
// 										If the latter selected undetected fault is not detected,
// 										atpgVals will have to be restored to previous atpgVals
// 										because the single pattern generation will change the
//										gate atpg values. If there is no more faults for DTC,
// 										the loop of DTC will be ended. After the loop, we will
// 										randomly XFill the pattern and perform fault simulation
// 										with the most recently updated pattern to drop the
// 										additional faults detected during the DTC phase.
// 								2.	FAULT_UNTESTABLE
// 										If the fault is not detected even after all the
// 										backtracks is done in the single pattern generation
// 										the fault is then declared as fault untestable.
// 								3.	ABORT
// 										If the Atpg is aborted due to the time of backtracks
// 										exceeding the BACKTRACK_LIMIT 500 (can be changed
// 										manually in namespace atpg.h::CoreNs).
//
// 							arguments:
// 								[in, out] faultPtrListForGen : Current list of fault
// 								pointers that are pointed to undetected faults. If detected
// 								when seen as the first selected target fault, it will be
// 								dropped immediately by fault simulation. If detected during
// 								DTC stage the faults will be dropped altogether after DTC.
//
// 								[in, out] pPatternProcessor : A pointer to pattern
// 								processor that contains a pattern vector recording the
// 								whole pattern set. In this function, the pattern processor
// 								should already possess the patterns generated for the
// 								faults before the current fault. A new Pattern will be
// 								pushed back to the the pPatternProcessor->patternVector_
// 								if the fault first selected in this function is detected.
// 								It will become pPatternProcessor->patternVector_.back().
// 								Then it will be determined and random XFilled at end of
// 								the function.
//
// 								[in, out] numOfAtpgUntestableFaults : It is a reference
// 								variable for recording the number of equivalent faults
// 								untestable. Here untestable faults means this function call
// 								has ended without abortion. If the function is aborted due
// 								to backtrack time exceeding limit, it is called aborted
// 								fault which is different to untestable fault.
//            ]
// Date       [ started 2020/07/07    last modified 2023/01/05 ]
// **************************************************************************
void Atpg::StuckAtFaultATPG(FaultPtrList &faultPtrListForGen, PatternProcessor *pPatternProcessor, int &numOfAtpgUntestableFaults)
{
	SINGLE_PATTERN_GENERATION_STATUS singlePatternGenerationResult = generateSinglePatternOnTargetFault(*faultPtrListForGen.front(), false);
	if (singlePatternGenerationResult == PATTERN_FOUND)
	{
		Pattern pattern(this->pCircuit_);
		pPatternProcessor->patternVector_.push_back(pattern);

		resetPrevAtpgValStoredToX();
		clearAllFaultEffectByEvaluation();
		storeCurrentAtpgVal();
		writeAtpgValToPatternPI(pPatternProcessor->patternVector_.back());

		if (pPatternProcessor->dynamicCompression_ == PatternProcessor::ON)
		{
			FaultPtrList faultPtrListForDTC = faultPtrListForGen;
			// the following function will drop faults detected by the pattern if any
			this->pSimulator_->parallelFaultFaultSimWithOnePattern(pPatternProcessor->patternVector_.back(), faultPtrListForGen);
			this->pSimulator_->goodSim();
			writeGoodSimValToPatternPO(pPatternProcessor->patternVector_.back());

			for (Fault *pFault : faultPtrListForDTC)
			{
				// skip detected faults
				if (pFault->faultState_ == Fault::DT)
				{
					continue;
				}

				Gate *pGateForActivation = getGateForFaultActivation(*pFault);
				// the atpgVal_ is already assigned to a value that is not able to detect the fault
				if (((pGateForActivation->atpgVal_ == L) && (pFault->faultType_ == Fault::SA0)) ||
						((pGateForActivation->atpgVal_ == H) && (pFault->faultType_ == Fault::SA1)))
				{
					continue;
				}

				// Activation check
				if (pGateForActivation->atpgVal_ != X)
				{
					if ((pFault->faultType_ == Fault::SA0) || (pFault->faultType_ == Fault::SA1))
					{
						setGateAtpgValAndEventDrivenEvaluation((*pGateForActivation), X);
					}
					else
					{
						continue;
					}
				}

				if (xPathExists(pGateForActivation))
				{
					// TO-DO homework 05
					// implement DTC here
					if (generateSinglePatternOnTargetFault(*pFault, true) == PATTERN_FOUND)
					{
						resetPrevAtpgValStoredToX();
						clearAllFaultEffectByEvaluation();
						storeCurrentAtpgVal();
						writeAtpgValToPatternPI(pPatternProcessor->patternVector_.back());
					}
					else
					{
						for (Gate &gate : this->pCircuit_->circuitGates_)
						{
							gate.atpgVal_ = gate.prevAtpgValStored_;
						}
					}
					// end of TO-DO
				}
				else
				{
					setGateAtpgValAndEventDrivenEvaluation((*pGateForActivation), pGateForActivation->prevAtpgValStored_);
				}
			}
		}

		clearAllFaultEffectByEvaluation();
		storeCurrentAtpgVal();
		writeAtpgValToPatternPI(pPatternProcessor->patternVector_.back());

		if (pPatternProcessor->XFill_ == PatternProcessor::ON)
		{
			// Randomly XFill the last pattern (most recently added pattern).
			// Note that the v_, gh_, gl_, fh_ and fl_ do not be changed.
			randomFill(pPatternProcessor->patternVector_.back());
		}

		// This function will assign PI/PPI stored in patternVector_.back() to
		// the gh_ and gl_ in each gate, and then it will run fault simulation
		// to drop fault.
		this->pSimulator_->parallelFaultFaultSimWithOnePattern(pPatternProcessor->patternVector_.back(), faultPtrListForGen);

		// After parallelFaultFaultSimWithOnePattern(), the PI/PPI values have
		// been passed to gh_ and gl_ of each gate. Therefore, we can directly
		// use "writeGoodSimValToPatternPO" to perform goodSim to get the PoValue.
		this->pSimulator_->goodSim();
		writeGoodSimValToPatternPO(pPatternProcessor->patternVector_.back());
	}
	else if (singlePatternGenerationResult == FAULT_UNTESTABLE)
	{
		faultPtrListForGen.front()->faultState_ = Fault::AU;
		numOfAtpgUntestableFaults += faultPtrListForGen.front()->equivalent_;
		faultPtrListForGen.pop_front();
	}
	else if (singlePatternGenerationResult == ABORT)
	{
		faultPtrListForGen.front()->faultState_ = Fault::AB;
		faultPtrListForGen.push_back(faultPtrListForGen.front());
		faultPtrListForGen.pop_front();
	}
}

// **************************************************************************
// Function   [ Atpg::getGateForFaultActivation ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
// 								This function is used in DTC stage.
//                Find and return the gate needed for fault activation, the
// 								will then went on to be checked if it is possible to be
// 								used for DTC stage.
//
// 							arguments:
//              	[in] faultToActivate: The latter fault selected to be
// 								activated in DTC stage.
// 							output:
// 								The return of this function is a gate pointer pointing to
// 								the gate needed to activated the faultToActivate.
//            ]
// Date       [ started 2020/07/07    last modified 2023/01/05 ]
// **************************************************************************
Gate *Atpg::getGateForFaultActivation(const Fault &faultToActivate)
{
	const bool faultIsAtGateOutput = (faultToActivate.faultyLine_ == 0);
	Gate *pGateForActivation = NULL;
	Gate *pFaultyGate = &(this->pCircuit_->circuitGates_[faultToActivate.gateID_]);
	if (!faultIsAtGateOutput)
	{
		pGateForActivation = &(this->pCircuit_->circuitGates_[pFaultyGate->faninVector_[faultToActivate.faultyLine_ - 1]]);
	}
	else
	{
		pGateForActivation = pFaultyGate;
	}
	return pGateForActivation;
}

// **************************************************************************
// Function   [ Atpg::setGateAtpgValAndEventDrivenEvaluation ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                Directly set the output of "gate" to "value" and run
// 								implication by event driven.
//
//              description:
// 								1.	Call clearEventStack() and set gate.atpgVal_ to "val"
// 								2.	For each fanout gate of gate, push the gateID into the
// 										event stack if not in the event stack.
// 								3.	Do event driven evaluation to update all the gates in
//										the event stack.
//
// 							arguments:
// 								[in] gate : The gate to set "val" to.
// 								[in] val : The "val" to assign to gate.atpgVal_.
//            ]
// Date       [ started 2020/07/07    last modified 2020/01/05 ]
// **************************************************************************
void Atpg::setGateAtpgValAndEventDrivenEvaluation(Gate &gate, const Value &val)
{
	clearEventStack(false); // false to disable debug mode of clearEventStack
	gate.atpgVal_ = val;
	for (const int &fanoutID : gate.fanoutVector_)
	{
		Gate &fanoutGate = this->pCircuit_->circuitGates_[fanoutID];
		if (this->isInEventStack_[fanoutGate.gateId_] == 0)
		{
			this->circuitLevel_to_eventStack_[fanoutGate.numLevel_].push(fanoutGate.gateId_);
			this->isInEventStack_[fanoutGate.gateId_] = 1;
		}
	}

	// event-driven simulation
	for (int level = gate.numLevel_; level < this->pCircuit_->totalLvl_; ++level)
	{
		while (!(this->circuitLevel_to_eventStack_[level].empty()))
		{
			const int gateID = this->circuitLevel_to_eventStack_[level].top();
			this->circuitLevel_to_eventStack_[level].pop();
			this->isInEventStack_[gateID] = 0;
			Gate &currGate = this->pCircuit_->circuitGates_[gateID];
			Value newValue = evaluateGoodVal(currGate);
			if (currGate.atpgVal_ != newValue)
			{
				currGate.atpgVal_ = newValue;
				for (int fanoutGateID : currGate.fanoutVector_)
				{
					const Gate &fanoutGate = this->pCircuit_->circuitGates_[fanoutGateID];
					if (this->isInEventStack_[fanoutGateID] == 0)
					{
						this->circuitLevel_to_eventStack_[fanoutGate.numLevel_].push(fanoutGateID);
						this->isInEventStack_[fanoutGateID] = 1;
					}
				}
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::resetPrevAtpgValStoredToX ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage: Reset the preV_ of each gate to X. ]
// Date       [ started 2020/07/07    last modified 2020/01/05 ]
// **************************************************************************
void Atpg::resetPrevAtpgValStoredToX()
{
	for (Gate &gate : this->pCircuit_->circuitGates_)
	{
		gate.prevAtpgValStored_ = X;
	}
}

// **************************************************************************
// Function   [ Atpg::storeCurrentAtpgVal ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                Store all the gate.atpgVal_ to gate.prevAtpgValStored_ in
// 								the circuit.
//
//              output:
// 								Count of values which change from H/L to the value which is not
//                the same as preV_.
//            ]
// Date       [ started 2020/07/04    last modified 2021/01/05 ]
// **************************************************************************
int Atpg::storeCurrentAtpgVal()
{
	int numAssignedValueChanged = 0;
	for (Gate &gate : this->pCircuit_->circuitGates_)
	{
		if ((gate.prevAtpgValStored_ != X) && (gate.prevAtpgValStored_ != gate.atpgVal_))
		{
			++numAssignedValueChanged;
		}
		gate.prevAtpgValStored_ = gate.atpgVal_;
	}

	if (numAssignedValueChanged != 0)
	{
		std::cerr << "Bug: storeCurrentAtpgVal detects the numAssignedValueChanged is not 0\n";
		std::cin.get();
	}
	return numAssignedValueChanged;
}

// **************************************************************************
// Function   [ Atpg::clearAllFaultEffectByEvaluation ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                Clear all the fault effects before test generation for next
//                target fault.
//            ]
// Date       [ started 2020/07/04    last modified 2023/01/05 ]
// **************************************************************************
void Atpg::clearAllFaultEffectByEvaluation()
{
	int numOfInputGate = this->pCircuit_->numPI_ + this->pCircuit_->numPPI_;
	for (Gate &gate : this->pCircuit_->circuitGates_)
	{
		if (gate.gateId_ < numOfInputGate)
		{
			// Remove fault effects in input gates
			clearFaultEffectOnGateAtpgVal(gate);
		}
		else
		{
			// Simulate the whole circuit
			gate.atpgVal_ = evaluateGoodVal(gate);
		}
	}
}

// **************************************************************************
// Function   [ Atpg::clearFaultEffectOnGateAtpgVal ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                This function replace value of a gate from D/B to H/L.
//              arguments:
// 								[in] gate : The gate to have atpgVal_ cleared.
//            ]
// Date       [ started 2020/07/04    last modified 2023/01/05 ]
// **************************************************************************
void Atpg::clearFaultEffectOnGateAtpgVal(Gate &gate)
{
	if (gate.atpgVal_ == D)
	{
		gate.atpgVal_ = H;
	}
	else if (gate.atpgVal_ == B)
	{
		gate.atpgVal_ = L;
	}
}

// **************************************************************************
// Function   [ Atpg::generateSinglePatternOnTargetFault ]
// Commenter  [ KOREAL WWS ]
// Synopsis   [ usage: Given a target fault, generate a pattern
//
// 								There are four main atpgStatus for backtrace while
// 								generating the pattern:
//
//									IMPLY_AND_CHECK: 	Determine as many signal values as
// 																		possible then check if the backtrace
//																		is meaningful or not.
//									DECISION:					Using the multiple backtrace procedure
// 																		to determine a final objective.
//									BACKTRACK:				If the values are incompatible during
// 																		propagation or implications,
// 																		backtracking is necessary.
//									JUSTIFY_FREE:			At the end of the process. Finding
// 																		values on the primary inputs which
// 																		justify all the values on the head
// 																		lines.
//
// 							description:
// 								First, call initialize:
// 									Set the pFaultyLineGate as the gate whose output is
// 									the target fault.
// 								Then, set the backtraceFlag to INITIAL.
// 								Keep calling doImplication() in a while loop, set the
// 								genStatus for latter return if PATTERN_FOUND,
//								FAULT_UNTESTABLE, ABORT corresponding to the scenario
// 								their literal meaning.
// 								Loop content(while):
// 									IF number of backtracks exceeds BACKTRACK_LIMIT, ABORT
// 									IF doImplication() return false(conflicts):
// 										Clear the event stack and set
// 										this->gateID_to_valModified to all false.
// 										Call backtrack()
// 										If backtrack() successful:
// 											Reset backtraceFlag to INITIAL for the latter
// 											findFinalObjectives(), set implicationStatus
// 											according to the BackImpLevel and reset
// 											pLastDFrontier to NULL
// 										Else IF backtrack() failed meaning all backtracks
// 											have been finished but there is still no pattern
// 											found.
// 											=> FAULT_UNTESTABLE
// 									Else IF doImplication() return true:
// 										IF continuationMeaningful() false:
// 											Then reset the backtraceFlag to INITIAL
// 										IF fault is propagated to any PO/PPO:
// 											IF there are any unjustified bound lines in circuit
// 												call findFinalObjective() and
// 												assignAtpgValToFinalObjectiveGates() and set
// 												implyStatus to FORWARD
// 											ELSE
// 												Justify all the free lines
// 												=> PATTERN_FOUND
// 										ELSE:
// 											IF the number of d-frontiers is 0:
// 												backtrack()
// 												IF backtrack successful:
// 													reset backtraceFlag to INITIAL
// 													...
// 												ELSE:
// 													=> FAULT_UNTESTABLE
// 											ELSE IF number of d-frontiers is 1:
// 												do unique sensitization:
// 													If UNIQUE_PATH_SENSITIZATION_FAIL:
// 														continue back to the while loop
// 														(will backtrack, no more dFrontier)
// 													ELSE IF sensitization successful
// 														implyStatus = BACKWARD and continue
// 													ELSE IF back implication level == 0
// 														continue;
// 													ELSE IF nothing happened
// 														call
// 														findFinalObjective() and
// 														assignAtpgValToFinalObjectiveGates()
// 														and set implyStatus to FORWARD
//
// 							arguments:
// 								[in] isAtStageDTC : The flag is true if this function is
// 								called during the DTC stage see
// 								Atpg::initializeForSinglePatternGeneration() for more
// 								of how this flag affect the behavior of this function.
//
// 								[in] targetFault : The target fault for this function to
//
//              output:
// 								SINGLE_PATTERN_GENERATION_STATUS,
// 								PATTERN_FOUND:		Single pattern generation successful.
// 																	A pattern is found for target fault.
// 								FAULT_UNTESTABLE:	The target fault is not detected
// 																	after all backtracks have ended.
// 								ABORT:	The single pattern generation is aborted due to
//												the time of backtracks exceeding the
// 												BACKTRACK_LIMIT(500).
//            ]
// Date       [ KOREAL Ver. 1.0 started 2013/08/10 last modified 2023/01/05 ]
// **************************************************************************
Atpg::SINGLE_PATTERN_GENERATION_STATUS Atpg::generateSinglePatternOnTargetFault(Fault targetFault, bool isAtStageDTC)
{
	int backwardImplicationLevel = 0;														// backward imply level
	int numOfBacktrack = 0;																			// backtrack times
	bool singlePatternGenProcessFinished = false;								// This boolean is true when whole pattern generation process is done
	bool faultHasPropagatedToPO = false;												// faultHasPropagatedToPO is true when the fault is propagate to the PO
	Gate *pFaultyLineGate = NULL;																// The gate pointer, whose output is the target fault
	Gate *pLastDFrontier = NULL;																// The D-frontier gate which has the highest level of all D-frontiers
	IMPLICATION_STATUS implicationStatus;												// The flag that decide the implication to go forward or backward
	BACKTRACE_STATUS backtraceFlag;															// The backtrace status { INITIAL, CHECK_AND_SELECT, CURRENT_OBJ_DETERMINE, FAN_OBJ_DETERMINE }
	SINGLE_PATTERN_GENERATION_STATUS genStatus = PATTERN_FOUND; // The status that will be return, including { PATTERN_FOUND, FAULT_UNTESTABLE, ABORT }

	// Get the gate whose output is fault line and set the backwardImplicationLevel
	// set a fault signal
	pFaultyLineGate = initializeForSinglePatternGeneration(targetFault, backwardImplicationLevel, implicationStatus, isAtStageDTC);
	// If there's no such gate, return FAULT_UNTESTABLE
	if (!pFaultyLineGate)
	{
		return FAULT_UNTESTABLE;
	}

	backtraceFlag = INITIAL;

	while (!singlePatternGenProcessFinished)
	{
		// implication inconsistency
		if (!doImplication(implicationStatus, backwardImplicationLevel))
		{
			if (this->backtrackDecisionTree_.lastNodeMarked())
			{
				++numOfBacktrack;
			}
			// ABORT if numOfBacktrack exceeds the BACKTRACK_LIMIT
			if (numOfBacktrack > BACKTRACK_LIMIT)
			{
				genStatus = ABORT;
				singlePatternGenProcessFinished = true;
			}

			clearAllEvents();

			// Is there an untried combination of values on assigned headlines or fanout points?
			// If yes, set untried combination of atpgVals in the function backtrack
			if (backtrack(backwardImplicationLevel))
			{
				// backtrack successful and initialize the data
				backtraceFlag = INITIAL;
				implicationStatus = (backwardImplicationLevel > 0) ? BACKWARD : FORWARD;
				pLastDFrontier = NULL;
			}
			else
			{
				// backtrack failed
				genStatus = FAULT_UNTESTABLE;
				singlePatternGenProcessFinished = true;
			}
			continue;
		}

		if (!continuationMeaningful(pLastDFrontier))
		{
			backtraceFlag = INITIAL;
		}

		// PO here indicating PO/PPO
		if (checkIfFaultHasPropagatedToPO(faultHasPropagatedToPO))
		{
			if (checkForUnjustifiedBoundLines())
			{
				// determine a final objective to assign atpgVal_
				findFinalObjective(backtraceFlag, faultHasPropagatedToPO, pLastDFrontier);
				// assign a value to the final objective's atpgVal_
				assignAtpgValToFinalObjectiveGates();
				implicationStatus = FORWARD;
				continue;
			}
			else
			{
				// Finding values on the primary inputs which justify all the values on the head lines
				// LINE JUSTIFICATION OF FREE LINES
				justifyFreeLines(targetFault);
				genStatus = PATTERN_FOUND;
				singlePatternGenProcessFinished = true;
			}
		}
		else // fault not propagated to PO/PPO
		{
			int numGatesInDFrontier = countEffectiveDFrontiers(pFaultyLineGate);

			// no frontier can propagate to the PO/PPO
			if (numGatesInDFrontier == 0)
			{
				if (this->backtrackDecisionTree_.lastNodeMarked())
				{
					// record the number of backtrack
					++numOfBacktrack;
				}

				// Abort if numOfBacktrack reaching the BACKTRACK_LIMIT
				if (numOfBacktrack > BACKTRACK_LIMIT)
				{
					genStatus = ABORT;
					singlePatternGenProcessFinished = true;
				}

				clearAllEvents();

				// Is there any untried combination of values on assigned headlines or fanouts?
				// If yes, set untried combination of values in the function backtrack
				if (backtrack(backwardImplicationLevel))
				{
					// backtrack success and initializeForSinglePatternGeneration the data
					// set backtrace flag
					backtraceFlag = INITIAL;
					implicationStatus = (backwardImplicationLevel > 0) ? BACKWARD : FORWARD;
					pLastDFrontier = NULL;
				}
				else
				{
					// backtrack fail
					genStatus = FAULT_UNTESTABLE;
					singlePatternGenProcessFinished = true;
				}
			}
			else if (numGatesInDFrontier == 1) // There exist just one path to the PO/PPO
			{
				backwardImplicationLevel = doUniquePathSensitization(this->pCircuit_->circuitGates_[this->dFrontiers_[0]]);
				// Unique Sensitization fail
				if (backwardImplicationLevel == UNIQUE_PATH_SENSITIZE_FAIL)
				{
					// If UNIQUE_PATH_SENSITIZE_FAIL, the number of gates in
					// d-frontier in the next while loop and will backtrack
					continue;
				}
				// Unique Sensitization success
				if (backwardImplicationLevel > 0)
				{
					implicationStatus = BACKWARD;
					continue;
				}
				else if (backwardImplicationLevel == 0)
				{
					continue;
				}
				else
				{
					// backwardImplicationLevel < 0, find an objective and set backtraceFlag and pLastDFrontier
					findFinalObjective(backtraceFlag, faultHasPropagatedToPO, pLastDFrontier);
					assignAtpgValToFinalObjectiveGates();
					implicationStatus = FORWARD;
					continue;
				}
			}
			else
			{ // more than one
				// determine a final objective to assign atpgVal_
				findFinalObjective(backtraceFlag, faultHasPropagatedToPO, pLastDFrontier);
				// assign value to the final objective line;s atpgVal_
				assignAtpgValToFinalObjectiveGates();
				implicationStatus = FORWARD;
				continue;
			}
		}
	}
	return genStatus;
}

// **************************************************************************
// Function   [ Atpg::initializeForSinglePatternGeneration ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
//                This function replace value of a gate from D/B to H/L.
//
// 							description:
// 								First, assign fault to this->currentTargetFault_ for the
//								future use of other functions.
// 								Then, assign the faulty gate to pFaultyLineGate. Initialize
// 								all the objectives and d-frontiers in Atpg.
// 								Initialize the circuit according to the faulty gate.
// 								IF gFaultyLine is free line,
// 									Set the value according to Fault.type_.
// 									SetFreeFaultyGate() to get the equivalent HEADLINE fault.
// 									Assign this->currentFault_ to the new fault.
// 									Set BackImpLevel to 0, implyStatus to FORWARD,
// 									faultyGateID to the new fault.gateID.
// 								ELSE
// 									setFaultyGate() to assign the BackImpLevel and assign
// 									the value of fanin gates of pFaultyLineGate and itself.
// 									Add the faultyGateID to the this->dFrontier_.
//									Do unique sensitization to pre assign some values and
// 									then set implyStatus to BACKWARD.
// 								Last,
// 									If fault.type_ is STR or STF, setup time frames for
// 									transition delay faults.
//
//              arguments:
// 								[in] targetFault : The target fault for single pattern
// 								generation, the faultyLine_ can be at input or output.
//
// 								[out] backwardImplicationLevel : The variable reference of
// 								backward implication level in single pattern generation,
// 								will be initialized according to the targetFault, and will
// 								be assigned to 0 if the implicationStatus is FORWARD.
//
// 								[out] implicationStatus : The variable reference of
// 								implication status in single pattern generation which
// 								indicates whether to do implication FORWARD or BACKWARD
// 								according to the targetFault.
//
// 								[in] isAtStageDTC : Specifying whether this function is
// 								called in the single pattern generation in DTC stage or
// 								not.
//            ]
// Date       [ last modified 2023/01/05 ]
// **************************************************************************
Gate *Atpg::initializeForSinglePatternGeneration(Fault &targetFault, int &backwardImplicationLevel, IMPLICATION_STATUS &implicationStatus, const bool &isAtStageDTC)
{
	Gate *pFaultyLineGate = &(this->pCircuit_->circuitGates_[targetFault.gateID_]); // the gate pointer; whose output is the target fault
	this->currentTargetFault_ = targetFault;

	// if targetFault at gate's input, change the pFaultyLineGate to the input gate
	if (targetFault.faultyLine_ != 0)
	{
		pFaultyLineGate = &(this->pCircuit_->circuitGates_[pFaultyLineGate->faninVector_[targetFault.faultyLine_ - 1]]);
	}
	initializeObjectivesAndFrontiers();
	initializeCircuitWithFaultyGate(*pFaultyLineGate, isAtStageDTC);
	int faultyGateID = targetFault.gateID_;

	if (this->gateID_to_lineType_[pFaultyLineGate->gateId_] == FREE_LINE)
	{
		if ((targetFault.faultType_ == Fault::SA0 || targetFault.faultType_ == Fault::STR) && pFaultyLineGate->atpgVal_ != L)
		{
			pFaultyLineGate->atpgVal_ = D;
		}
		if ((targetFault.faultType_ == Fault::SA1 || targetFault.faultType_ == Fault::STF) && pFaultyLineGate->atpgVal_ != H)
		{
			pFaultyLineGate->atpgVal_ = B;
		}
		this->backtrackImplicatedGateIDs_.push_back(pFaultyLineGate->gateId_);

		this->currentTargetHeadLineFault_ = setFreeLineFaultyGate(*pFaultyLineGate);
		this->currentTargetFault_ = this->currentTargetHeadLineFault_;
		backwardImplicationLevel = 0;
		implicationStatus = FORWARD;
		faultyGateID = this->currentTargetHeadLineFault_.gateID_;
	}
	else
	{
		backwardImplicationLevel = setFaultyGate(targetFault);
	}

	if (backwardImplicationLevel < 0)
	{
		return NULL;
	}

	this->dFrontiers_.push_back(faultyGateID);

	int Level = doUniquePathSensitization(this->pCircuit_->circuitGates_[faultyGateID]);
	if (Level == UNIQUE_PATH_SENSITIZE_FAIL)
	{
		return NULL;
	}

	if (Level > backwardImplicationLevel)
	{
		backwardImplicationLevel = Level;
		implicationStatus = BACKWARD;
	}

	if (targetFault.faultType_ == Fault::STR || targetFault.faultType_ == Fault::STF)
	{
		Level = setUpFirstTimeFrame(targetFault);
		if (Level < 0)
		{
			return NULL;
		}

		if (Level > backwardImplicationLevel)
		{
			backwardImplicationLevel = Level;
			implicationStatus = BACKWARD;
		}
	}
	return &(this->pCircuit_->circuitGates_[faultyGateID]);
}

// **************************************************************************
// Function   [ Atpg::initializeObjectivesAndFrontiers ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
//                This function clear all the objectives,
// 								and most of the attributes.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
void Atpg::initializeObjectivesAndFrontiers()
{
	this->initialObjectives_.clear();
	this->currentObjectives_.clear();
	this->fanoutObjectives_.clear();
	this->headLineObjectives_.clear();
	this->finalObjectives_.clear();
	this->initialObjectives_.reserve(MAX_LIST_SIZE);
	this->currentObjectives_.reserve(MAX_LIST_SIZE);
	this->fanoutObjectives_.reserve(MAX_LIST_SIZE);
	this->headLineObjectives_.reserve(MAX_LIST_SIZE);
	this->finalObjectives_.reserve(MAX_LIST_SIZE);

	this->unjustifiedGateIDs_.clear();
	this->dFrontiers_.clear();
	this->backtrackImplicatedGateIDs_.clear();
	this->backtrackDecisionTree_.clear();
	this->currentTargetHeadLineFault_ = Fault(); // NE
	this->firstTimeFrameHeadLine_ = NULL;
	this->unjustifiedGateIDs_.reserve(MAX_LIST_SIZE);
	this->dFrontiers_.reserve(MAX_LIST_SIZE);
	this->backtrackImplicatedGateIDs_.reserve(this->pCircuit_->totalGate_);
}

// **************************************************************************
// Function   [ Atpg::initializeCircuitWithFaultyGate ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
//                Initialize the gates' atpgVal_ and vectors in Atpg (Ex:
// 								gateID_to_...)
//
// 							description:
// 								Traverse through all the gates in the circuit.
// 								If the gate is free line,
// 									set gateID_to_valModified_ to true
// 									(free line doesn't need to be implicated/backtraced)
// 								else set gateID_to_valModified_ to false.
// 								Initialize this->gateID_to_reachableByTargetFault_ to all
// 								 false.(All gate not reachable as default)
// 								Assign all gates' atpgVal_ to X if isAtStageDTC is false.
// 								(Keep the atpgVal_ from previous single pattern generation
// 								on first selected target fault or updated atpgVal_ during
// 								previous iteration in DTC)
// 								Initialize the whole Atpg::xPathStatus_ to UNKNOWN for
// 								future xPathTracing().
// 								Set this->gateID_to_reachableByTargetFault_ to 1 and
// 								this->gateID_to_valModified_[gate.gateId_] to 0 for all
// 								the reachable fanout from the faultyGate.
//
// 							arguments:
// 								[in] faultyGate: The gate whose output is faulty.
//
// 								[in] isAtStageDTC: Specifies if the single pattern
// 								generation is at DTC stage.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
void Atpg::initializeCircuitWithFaultyGate(const Gate &faultyGate, const bool &isAtStageDTC)
{
	for (Gate &gate : this->pCircuit_->circuitGates_)
	{
		if (this->gateID_to_lineType_[gate.gateId_] == FREE_LINE)
		{
			this->gateID_to_valModified_[gate.gateId_] = 1;
		}
		else
		{
			this->gateID_to_valModified_[gate.gateId_] = 0;
		}
		this->gateID_to_reachableByTargetFault_[gate.gateId_] = 0;

		// assign value outside the generateSinglePatternOnTargetFault for DTC, so
		// only need to initializeForSinglePatternGeneration it for primary fault.
		if (!isAtStageDTC)
		{
			gate.atpgVal_ = X;
		}
		this->gateID_to_xPathStatus_[gate.gateId_] = UNKNOWN;
	}

	pushGateToEventStack(faultyGate.gateId_);

	for (int i = faultyGate.numLevel_; i < this->pCircuit_->totalLvl_; ++i)
	{
		while (!this->circuitLevel_to_eventStack_[i].empty())
		{
			int gateID = popEventStack(i);
			const Gate &rCurrentGate = this->pCircuit_->circuitGates_[gateID];
			this->gateID_to_valModified_[gateID] = 0;
			this->gateID_to_reachableByTargetFault_[gateID] = 1;

			for (int fanoutID : rCurrentGate.fanoutVector_)
			{
				pushGateToEventStack(fanoutID);
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::clearEventStack ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                Clear this->circuitLevel_to_eventStack_.
// 								Set this->gateID_to_valModified_ and
// 								this->isInEventStack_ to 0.
//
// 							arguments:
// 								[in] isDebug: Check this->isInEventStack_ correctness if
// 								the flag is true.
//            ]
// Date       [ started 2020/07/07    last modified 2023/01/06 ]
// **************************************************************************
void Atpg::clearEventStack(bool isDebug)
{

	// pop and remove mark
	for (std::stack<int> &eventStack : this->circuitLevel_to_eventStack_)
	{
		while (!eventStack.empty())
		{
			const int gateID = eventStack.top();
			eventStack.pop();
			this->gateID_to_valModified_[gateID] = 0;
			this->isInEventStack_[gateID] = 0;
		}
	}

	// expect all gates in circuit must be unmarked
	// after the above for-loop.
	if (isDebug)
	{
		for (int i = 0; i < this->pCircuit_->totalGate_; ++i)
		{
			if (this->isInEventStack_[i])
			{
				std::cerr << "Bug: Warning clearEventStack found unexpected behavior\n";
				this->isInEventStack_[i] = 0;
				std::cin.get();
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::doImplication ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage:	Do BACKWARD and FORWARD implications to gates in
// 								this->circuitLevel_to_eventStack_
//
// 							description:
// 								Enter a do while (backward) loop
// 								Loop content :
// 									IF the status is backward:
// 										Do evaluation backward starting from
//										this->circuitLevel_to_eventStack_[implicationStartLevel]
// 										to this->circuitLevel_to_eventStack_[0].
// 									Then, do evaluation() forward from Atpg::eventList_[0]
// 									to Atpg::eventList_[totalLevel].
// 								evaluateAndSetGateAtpgVal() will return
// 									FORWARD : do nothing
// 									BACKWARD :
// 										Do nothing if doing evaluations backward.
// 										If doing evaluations forward,
// 										immediately break current loop and go back to the loop
// 										doing backward evaluations in the event stack.
// 									CONFLICT : any failed evaluations
//
//              arguments:
// 								[in] atpgStatus: Indicating the current atpg implication
// 								direction (FORWARD or BACKWARD)
//
// 								[in] implicationStartLevel: The starting circuit level to do
// 								implications in this function.
//
//              output:
// 								A boolean,
// 								Return false if conflict after evaluateAndSetGateAtpgVal()
// 								Return true if no conflicts for all implications
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 2023/01/06 ]
// **************************************************************************
bool Atpg::doImplication(IMPLICATION_STATUS atpgStatus, int implicationStartLevel)
{
	// A local variable for storing status of evaluateAndSetGateAtpgVal()
	IMPLICATION_STATUS implicationStatusOfEval;
	if (atpgStatus != BACKWARD)
	{
		implicationStartLevel = 0;
	}

	do
	{
		if (atpgStatus == BACKWARD)
		{
			// BACKWARD loop: Do evaluateAndSetGateAtpgVal() to gates in
			// this->circuitLevel_to_eventStack_ in BACKWARD order from implicationStartLevel.
			// If one of them returns CONFLICT, returns false.
			for (int i = implicationStartLevel; i >= 0; --i)
			{
				while (!this->circuitLevel_to_eventStack_[i].empty())
				{
					Gate *pGate = &this->pCircuit_->circuitGates_[popEventStack(i)];
					implicationStatusOfEval = evaluateAndSetGateAtpgVal(pGate);
					if (implicationStatusOfEval == CONFLICT)
					{
						return false;
					}
				}
			}
		}

		atpgStatus = FORWARD;
		for (int i = 0; i < this->pCircuit_->totalLvl_; ++i)
		{
			// FORWARD loop: Do evaluateAndSetGateAtpgVal() to gates in
			// this->circuitLevel_to_eventStack_ in FORWARD order till it gets
			// to MaxLevel.
			// If one of them returns CONFLICT, returns false.
			// If one of them returns BACKWARD, set implicationStartLevel
			// to current level - 1
			// break for loop
			while (!this->circuitLevel_to_eventStack_[i].empty())
			{
				Gate *pGate = &this->pCircuit_->circuitGates_[popEventStack(i)];
				implicationStatusOfEval = evaluateAndSetGateAtpgVal(pGate);
				if (implicationStatusOfEval == CONFLICT)
				{
					return false;
				}
				else if (implicationStatusOfEval == BACKWARD)
				{
					implicationStartLevel = i - 1;
					atpgStatus = BACKWARD;
					break;
				}
			}

			if (atpgStatus == BACKWARD)
			{
				break;
			}
		}
	} while (atpgStatus == BACKWARD);

	return true;
}

// **************************************************************************
// Function   [ Atpg::doOneGateBackwardImplication ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
// 								Do backward implication on one gate.
//
// 							descriptions:
// 								This function is specific designed for
//								this->evaluateAndSetGateAtpgVal() to call when pGate's
// 								atpgVal_ can’t be evaluated due to the lack of determined
// 								gate inputs’ values.
// 								This function is aimed to keep doing implication backward
// 								starting from pGate.
// 								It will return FORWARD when reach PI/PPI or is unable to
// 								justify atpgVal_, otherwise it will return BACKWARD.
// 								Note that this function will never return CONFLICT.
//
// 							arguments:
// 								[in] pGate: The pointer to the gate to do backward
// 								implication on.
//
// 							output:
// 								IMPLICATION_STATUS,
// 								Whether to implicate forward or backward
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
Atpg::IMPLICATION_STATUS Atpg::doOneGateBackwardImplication(Gate *pGate)
{
	int numOfX = 0;
	int faninIndex = 0;
	Gate *pFaninGate0 = NULL;
	Gate *pFaninGate1 = NULL;
	Gate *pFaninGate2 = NULL;
	Gate *pImplicatedGate = NULL;
	IMPLICATION_STATUS implicationStatus = FORWARD;
	const Value inputControlVal = pGate->getInputCtrlValue();
	const Value outputControlVal = pGate->getOutputCtrlValue();
	const Value inputNonControlVal = pGate->getInputNonCtrlValue();

	switch (pGate->gateType_)
	{
		case Gate::PI:
		case Gate::PPI:
			return FORWARD;
		case Gate::BUF:
		case Gate::INV:
		case Gate::PO:
		case Gate::PPO:
			pImplicatedGate = &(this->pCircuit_->circuitGates_[pGate->faninVector_[0]]);
			this->gateID_to_valModified_[pGate->gateId_] = 1;

			if (pGate->gateType_ == Gate::INV)
			{
				pImplicatedGate->atpgVal_ = cXOR2(pGate->atpgVal_, H);
			}
			else
			{
				pImplicatedGate->atpgVal_ = cXOR2(pGate->atpgVal_, L);
			}

			this->backtrackImplicatedGateIDs_.push_back(pImplicatedGate->gateId_);
			pushGateToEventStack(pGate->faninVector_[0]);
			pushGateFanoutsToEventStack(pGate->faninVector_[0]);
			implicationStatus = BACKWARD;
			break;
		case Gate::XOR2:
		case Gate::XNOR2:
			implicationStatus = BACKWARD;
			pFaninGate0 = &(this->pCircuit_->circuitGates_[pGate->faninVector_[0]]);
			pFaninGate1 = &(this->pCircuit_->circuitGates_[pGate->faninVector_[1]]);

			if (pFaninGate0->atpgVal_ == X && pFaninGate1->atpgVal_ != X)
			{
				if (pGate->gateType_ == Gate::XOR2)
				{
					pFaninGate0->atpgVal_ = cXOR2(pGate->atpgVal_, pFaninGate1->atpgVal_);
				}
				else
				{
					pFaninGate0->atpgVal_ = cXNOR2(pGate->atpgVal_, pFaninGate1->atpgVal_);
				}
				this->gateID_to_valModified_[pGate->gateId_] = 1;
				this->backtrackImplicatedGateIDs_.push_back(pFaninGate0->gateId_);
				pushGateToEventStack(pGate->faninVector_[0]);
				pushGateFanoutsToEventStack(pGate->faninVector_[0]);
			}
			else if (pFaninGate1->atpgVal_ == X && pFaninGate0->atpgVal_ != X)
			{
				if (pGate->gateType_ == Gate::XOR2)
				{
					pFaninGate1->atpgVal_ = cXOR2(pGate->atpgVal_, pFaninGate0->atpgVal_);
				}
				else
				{
					pFaninGate1->atpgVal_ = cXNOR2(pGate->atpgVal_, pFaninGate0->atpgVal_);
				}
				this->gateID_to_valModified_[pGate->gateId_] = 1;
				this->backtrackImplicatedGateIDs_.push_back(pFaninGate1->gateId_);
				pushGateToEventStack(pGate->faninVector_[1]);
				pushGateFanoutsToEventStack(pGate->faninVector_[1]);
			}
			else
			{
				implicationStatus = FORWARD;
				this->unjustifiedGateIDs_.push_back(pGate->gateId_);
			}
			break;
		case Gate::XOR3:
		case Gate::XNOR3:
			numOfX = 0;
			faninIndex = 0;
			pFaninGate0 = &(this->pCircuit_->circuitGates_[pGate->faninVector_[0]]);
			pFaninGate1 = &(this->pCircuit_->circuitGates_[pGate->faninVector_[1]]);
			pFaninGate2 = &(this->pCircuit_->circuitGates_[pGate->faninVector_[2]]);
			if (pFaninGate0->atpgVal_ == X)
			{
				++numOfX;
				faninIndex = 0;
			}
			if (pFaninGate1->atpgVal_ == X)
			{
				++numOfX;
				faninIndex = 1;
			}
			if (pFaninGate2->atpgVal_ == X)
			{
				++numOfX;
				faninIndex = 2;
			}
			if (numOfX == 1)
			{
				pImplicatedGate = &this->pCircuit_->circuitGates_[pGate->faninVector_[faninIndex]];
				Value temp;
				if (faninIndex == 0)
				{
					temp = cXOR3(pGate->atpgVal_, pFaninGate1->atpgVal_, pFaninGate2->atpgVal_);
				}
				else if (faninIndex == 1)
				{
					temp = cXOR3(pGate->atpgVal_, pFaninGate0->atpgVal_, pFaninGate2->atpgVal_);
				}
				else
				{
					temp = cXOR3(pGate->atpgVal_, pFaninGate1->atpgVal_, pFaninGate0->atpgVal_);
				}

				if (pGate->gateType_ == Gate::XNOR3)
				{
					temp = cINV(temp);
				}
				pImplicatedGate->atpgVal_ = temp;
				this->gateID_to_valModified_[pGate->gateId_] = 1;
				this->backtrackImplicatedGateIDs_.push_back(pImplicatedGate->gateId_);
				pushGateToEventStack(pGate->faninVector_[faninIndex]);
				pushGateFanoutsToEventStack(pGate->faninVector_[faninIndex]);
				implicationStatus = BACKWARD;
			}
			else
			{
				this->unjustifiedGateIDs_.push_back(pGate->gateId_);
				implicationStatus = FORWARD;
			}
			break;
		default:
			if (pGate->atpgVal_ == outputControlVal)
			{
				this->gateID_to_valModified_[pGate->gateId_] = 1;

				for (int faninGateID : pGate->faninVector_)
				{
					Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
					if (faninGate.atpgVal_ == X)
					{
						faninGate.atpgVal_ = inputNonControlVal;
						this->backtrackImplicatedGateIDs_.push_back(faninGateID);
						pushGateToEventStack(faninGateID);
						pushGateFanoutsToEventStack(faninGateID);
					}
				}
				implicationStatus = BACKWARD;
			}
			else
			{
				numOfX = 0;
				faninIndex = 0;
				int index = 0;
				for (int faninGateID : pGate->faninVector_)
				{
					Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
					if (faninGate.atpgVal_ == X)
					{
						++numOfX;
						faninIndex = index;
					}
					++index;
				}

				if (numOfX == 1)
				{
					pImplicatedGate = &(this->pCircuit_->circuitGates_[pGate->faninVector_[faninIndex]]);
					pImplicatedGate->atpgVal_ = inputControlVal;
					this->gateID_to_valModified_[pGate->gateId_] = 1;
					this->backtrackImplicatedGateIDs_.push_back(pImplicatedGate->gateId_);
					pushGateToEventStack(pGate->faninVector_[faninIndex]);
					pushGateFanoutsToEventStack(pGate->faninVector_[faninIndex]);
					implicationStatus = BACKWARD;
				}
				else
				{
					this->unjustifiedGateIDs_.push_back(pGate->gateId_);
					implicationStatus = FORWARD;
				}
			}
			break;
	}
	return implicationStatus;
}

// **************************************************************************
// Function   [ Atpg::backtrack ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage: When we backtrack a single gate in the decision tree,
// 								we need to recover all the associated implications
// 								starting from the startPoint of its DecisionTreeNode as
// 								a index in this->backtrackImplicatedGateIDs_.
//
// 							description:
// 								Check if the decisionTree_.get(...) is True
// 								If true : DecisionTreeNode already marked,
// 									pop it from decision tree and check next bottom node
// 								Else :
// 									update the unjustified lines
// 								Backtrack the gate's atpgVal_ from previous decisionTree_.get(),
// 								reset all the gate in the Atpg::backtrackList_ to
// 								not modified and the value to unknown,
// 								Recalculate the BackImpLevel, reconstruct the event stack,
// 								this->dFrontier_, this->Atpg::unjustified_, this->xPathStatus
// 								return true, indicating backtrack successful
// 								if no more gate(node) in decision tree to backtrack than
// 								return false, indicating backtrack failed, fault untestable
//
// 							arguments:
// 								[out] backwardImplicationLevel: backward implication level
// 								of current single pattern generation, will be updated in
// 								in this function if any backtrack happened
//
//              output:
// 								A boolean indicating whether backtrack has failed, if
// 								failed the whole current target fault is determined as
// 								untestable in this atpg algorithm.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
//
// The decision gates are put in the decisionTree
// The associated implications of corresponding decision gates are put
// in this->backtrackImplicatedGateIDs_.
//
// When we backtrack a single gate in decision tree, we need to recover all
// the associated implications starting from the startPoint in
// this->backtrackImplicatedGateIDs_.
//
//                       +------+------+
//  DecisionTreeNodes  : | G0=1 | G1=0 |...
//                       +------+------+
//       startPoint of G0=1 |        \ startPoint of G1=0
//                          V         \						.
//                       +----+----++----+----+----+
//  backtrackList:       |G4=0|G7=1||G6=1|G9=0|G8=0|...
//                       +----+----++----+----+----+
//                       \____ ____/\______ _______/
//                            V            V
// associated implications of G0=1         associated implications of G1=0
//
// **************************************************************************
bool Atpg::backtrack(int &backwardImplicationLevel)
{
	// this->backtrackImplicatedGateIDs_ is allocated for this function
	int decisionGateID;
	int backtrackPoint = 0;
	Gate *pDecisionGate = NULL;

	while (!this->backtrackDecisionTree_.empty())
	{
		// get the last node in this->backtrackDecisionTree_ as backtrackPoint
		if (this->backtrackDecisionTree_.get(decisionGateID, backtrackPoint))
		{
			continue;
		}

		updateUnjustifiedGateIDs();
		// pDecisionGate is the bottom(last) node of this->backtrackDecisionTree_
		pDecisionGate = &(this->pCircuit_->circuitGates_[decisionGateID]);
		Value toggledBacktrackNodeAtpgVal = cINV(pDecisionGate->atpgVal_);

		for (int i = backtrackPoint; i < (int)this->backtrackImplicatedGateIDs_.size(); ++i)
		{
			// Reset gates and their ouput in this->backtrackImplicatedGateIDs_,
			// starting from its backtrack point.
			Gate *pGate = &(this->pCircuit_->circuitGates_[this->backtrackImplicatedGateIDs_[i]]);

			pGate->atpgVal_ = X;
			this->gateID_to_valModified_[pGate->gateId_] = 0;

			for (int fanoutGateID : pGate->fanoutVector_)
			{
				this->gateID_to_valModified_[fanoutGateID] = 0;
			}
		}

		backwardImplicationLevel = 0;

		for (int i = backtrackPoint + 1; i < (int)this->backtrackImplicatedGateIDs_.size(); ++i)
		{
			// Find MAX level output in this->backtrackImplicatedGateIDs_
			// and save it to backwardImplicationLevel
			Gate *pGate = &(this->pCircuit_->circuitGates_[this->backtrackImplicatedGateIDs_[i]]);

			for (int fanoutGateID : pGate->fanoutVector_)
			{
				Gate &fanoutGate = this->pCircuit_->circuitGates_[fanoutGateID];
				if (fanoutGate.atpgVal_ != X)
				{
					if (!this->gateID_to_valModified_[fanoutGate.gateId_])
					{
						this->unjustifiedGateIDs_.push_back(fanoutGate.gateId_);
					}
					pushGateToEventStack(fanoutGate.gateId_);
				}

				if (fanoutGate.numLevel_ > backwardImplicationLevel)
				{
					backwardImplicationLevel = fanoutGate.numLevel_;
				}
			}
		}
		// cut the last backtracked point and its associated gates
		this->backtrackImplicatedGateIDs_.resize(backtrackPoint + 1);
		// toggle its value, do backtrack, ex: 1=>0, 0=>1
		pDecisionGate->atpgVal_ = toggledBacktrackNodeAtpgVal;

		if (this->gateID_to_lineType_[pDecisionGate->gateId_] == HEAD_LINE)
		{
			this->gateID_to_valModified_[pDecisionGate->gateId_] = 0;
		}
		else
		{
			pushGateToEventStack(pDecisionGate->gateId_);
		}

		pushGateFanoutsToEventStack(pDecisionGate->gateId_);

		this->dFrontiers_.clear();
		this->dFrontiers_.reserve(MAX_LIST_SIZE);
		this->dFrontiers_.push_back(this->currentTargetFault_.gateID_);
		updateDFrontiers();

		// Update this->unjustifiedGateIDs_
		for (int k = (int)(this->unjustifiedGateIDs_.size()) - 1; k >= 0; --k)
		{
			if (this->pCircuit_->circuitGates_[this->unjustifiedGateIDs_[k]].atpgVal_ == X)
			{
				vecDelete(this->unjustifiedGateIDs_, k);
			}
		}
		// Reset all xPathStatus to unknown
		std::fill(this->gateID_to_xPathStatus_.begin(), this->gateID_to_xPathStatus_.end(), UNKNOWN);
		return true;
	}
	return false;
}

// **************************************************************************
// Function   [ Atpg::continuationMeaningful ]
// Commenter  [ WWS ]
// Synopsis   [ usage: Used in single pattern generation to see if it is
// 								meaningful to continue.
//
// 							description:
//                Clear this->circuitLevel_to_eventStack_.
// 								Set this->gateID_to_valModified_ and
// 								this->isInEventStack_ to 0.
//
// 							arguments:
// 								First call Atpg::updateUnjustifiedLines()
// 								If any gate in this->initialObjectives_ is modified,
// 								pop it from this->initialObjectives_
// 								If the atpgVal_ of last D-Frontier has changed
// 								or all init objectives modified(Atpg::initIObject_.empty()),
// 								there is no need to continue doing the backtrace based
// 								on the current status.
//
// 							output:
// 								A boolean indicating if continuation in atpg is meaningful.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
bool Atpg::continuationMeaningful(Gate *pLastDFrontier)
{
	// dFrontierChanged is true when D-frontier must change
	bool dFrontierChanged;

	updateUnjustifiedGateIDs();

	for (int k = (int)this->initialObjectives_.size() - 1; k >= 0; --k)
	{
		if (this->gateID_to_valModified_[this->initialObjectives_[k]])
		{
			vecDelete(this->initialObjectives_, k);
		}
	}

	// determine if the pLastDFrontier should be changed or not
	if (pLastDFrontier != NULL)
	{
		if (pLastDFrontier->atpgVal_ == X)
		{
			dFrontierChanged = false;
		}
		else
		{
			dFrontierChanged = true;
		}
	}
	else
	{
		dFrontierChanged = true;
	}
	// If all this->initialObjectives_ have been modified
	// or the last D-frontier has changed,
	// Reset backtrace atpgStatus
	return !(this->initialObjectives_.empty() || dFrontierChanged);
}

// **************************************************************************
// Function   [ Atpg::updateUnjustifiedGateIDs ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage: update this->unjustifiedGateIDs_
//
// 							description:
// 								Traverse all gates in this->unjustifiedGateIDs_, if any
// 								gate was put into unjustified list but was implied
// 								afterwards by other gates, remove those gates from
// 								this->unjustifiedGateIDs_.
// 								IF this->gateID_to_valModified_[modifiedGate.gateId_]  == true,
// 									Delete it from this->unjustifiedGateIDs_
// 								Else
// 									Push modifiedGate into this->finalObjectives_
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::updateUnjustifiedGateIDs()
{
	for (int i = this->unjustifiedGateIDs_.size() - 1; i >= 0; --i)
	{
		const Gate &modifiedGate = this->pCircuit_->circuitGates_[this->unjustifiedGateIDs_[i]];
		if (this->gateID_to_valModified_[modifiedGate.gateId_])
		{
			vecDelete(this->unjustifiedGateIDs_, i);
		}
		else
		{
			this->gateID_to_valModified_[modifiedGate.gateId_] = 0;
			this->finalObjectives_.push_back(modifiedGate.gateId_);
		}
	}

	// Pop all elements from this->finalObjectives_
	// and set all of their this->gateID_to_valModified_ to 0.
	while (!this->finalObjectives_.empty())
	{
		const int gateID = vecPop(this->finalObjectives_);
		this->gateID_to_valModified_[gateID] = 0;
	}
}

// **************************************************************************
// Function   [ Atpg::updateDFrontiers ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage: update this->dFrontiers_
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::updateDFrontiers()
{
	int dFrontiersIndex = 0;
	while (dFrontiersIndex < (int)dFrontiers_.size())
	{
		const int gateID = this->dFrontiers_[dFrontiersIndex];
		switch (pCircuit_->circuitGates_[gateID].atpgVal_)
		{
			case B:
			case D:
				for (int fanoutGateID : pCircuit_->circuitGates_[gateID].fanoutVector_)
				{
					this->dFrontiers_.push_back(fanoutGateID);
				}
				vecDelete(this->dFrontiers_, dFrontiersIndex);
				break;
			case X:
				++dFrontiersIndex;
				break;
			default:
				vecDelete(this->dFrontiers_, dFrontiersIndex);
				break;
		}
	}
}

// **************************************************************************
// Function   [ Atpg::checkIfFaultHasPropagatedToPO ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
// 							description:
// 								If there is any D or B at PO/PPO, assign
// 								faultHasPropagatedToPO to true and return true.
// 								Otherwise assign false and return false.
//
// 							arguments:
// 								[out] faultHasPropagatedToPO:
// 									Will be assigned to true if the literal meaning of this
// 									variable happened.
// 							output:
// 								A boolean value same to faultHasPropagatedToPO
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
bool Atpg::checkIfFaultHasPropagatedToPO(bool &faultHasPropagatedToPO)
{
	for (int i = 0; i < this->pCircuit_->numPO_ + this->pCircuit_->numPPI_; ++i)
	{
		const Value &v = this->pCircuit_->circuitGates_[this->pCircuit_->totalGate_ - i - 1].atpgVal_;
		if (v == D || v == B)
		{
			faultHasPropagatedToPO = true;
			return true;
		}
	}
	faultHasPropagatedToPO = false;
	return false;
}

// **************************************************************************
// Function   [ Atpg::checkForUnjustifiedBoundLines ]
// Commenter  [ WWS ]
// Synopsis   [ usage: Check for any left unjustified bound lines.
// 							output:
// 								A boolean indicating if any unjustified bound lines are
// 								left in current single pattern generation.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
bool Atpg::checkForUnjustifiedBoundLines()
{
	for (const int &unjustifiedGateID : this->unjustifiedGateIDs_)
	{
		const Gate &unjustifiedGate = this->pCircuit_->circuitGates_[unjustifiedGateID];
		const bool gateIsUnjustifiedBoundLine = (unjustifiedGate.atpgVal_ != X) &&
																						!(this->gateID_to_valModified_[unjustifiedGateID]) &&
																						(this->gateID_to_lineType_[unjustifiedGateID] == BOUND_LINE);
		if (gateIsUnjustifiedBoundLine)
		{
			return true;
		}
	}
	return false;
}

// **************************************************************************
// Function   [ Atpg::findFinalObjective ]
// Commenter  [ WYH WWS ]
// Synopsis   [ usage: Determination of final objectives.
// 							description:
// 								Choose a value and a line such that if the chosen value is
// 								assigned to the chosen line the initial objectives will be
// 								satisfied.
//              arguments:
// 								[in, out] BACKTRACE_STATUS& backtraceFlag: It indicates
// 									the backtrace atpgStatus.
//                [in] faultCanPropToPO: It indicates whether the
//                  fault signal can propagate to PO/PPO or not.
//                [in, out] pLastDFrontier: A pointer reference of pointer
// 								of the last d-frontier in current single pattern generation.
//            ]
// Date       [ WYH Ver. 1.0 started 2013/08/15 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::findFinalObjective(BACKTRACE_STATUS &backtraceFlag, const bool &faultCanPropToPO, Gate *&pLastDFrontier)
{
	int possibleFinalObjectiveID = -1;

	while (true)
	{
		if (backtraceFlag == INITIAL)
		{
			backtraceFlag = FAN_OBJ_DETERMINE;
			for (const int &gateID : this->gateIDsToResetAfterBackTrace_)
			{
				setGaten0n1(gateID, 0, 0);
			}

			clearAllObjectives();
			this->gateIDsToResetAfterBackTrace_.clear();
			this->gateIDsToResetAfterBackTrace_.reserve(this->pCircuit_->totalGate_);

			if (!this->unjustifiedGateIDs_.empty())
			{
				this->initialObjectives_ = this->unjustifiedGateIDs_;

				if (faultCanPropToPO)
				{
					pLastDFrontier = NULL;
				}
				else
				{
					int index;
					pLastDFrontier = findClosestToPO(this->dFrontiers_, index);
					this->initialObjectives_.push_back(pLastDFrontier->gateId_);
				}
			}
			else
			{
				int index;
				pLastDFrontier = findClosestToPO(this->dFrontiers_, index);
				this->initialObjectives_.push_back(pLastDFrontier->gateId_);
			}

			// multiple backtrace from the initial objectives
			if (multipleBacktrace(INITIAL, possibleFinalObjectiveID) == CONTRADICTORY)
			{
				this->finalObjectives_.push_back(possibleFinalObjectiveID);
				return;
			}
		}
		else
		{
			if (!this->fanoutObjectives_.empty())
			{
				// multiple backtrace from a fanout point objectives
				if (multipleBacktrace(FAN_OBJ_DETERMINE, possibleFinalObjectiveID) == CONTRADICTORY)
				{
					this->finalObjectives_.push_back(possibleFinalObjectiveID);
					return;
				}
			}
		}

		while (true)
		{
			if (this->headLineObjectives_.empty())
			{
				backtraceFlag = INITIAL;
				break;
			}
			else
			{
				// pop and take a headline objective
				const Gate &aHeadLineObjectiveGate = this->pCircuit_->circuitGates_[vecPop(this->headLineObjectives_)];
				if (aHeadLineObjectiveGate.atpgVal_ == X)
				{
					this->finalObjectives_.push_back(aHeadLineObjectiveGate.gateId_);
					return;
				}
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::clearAllObjectives ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
// 								Clear and reinitialize all the objectives.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
void Atpg::clearAllObjectives()
{
	this->initialObjectives_.clear();
	this->currentObjectives_.clear();
	this->fanoutObjectives_.clear();
	this->headLineObjectives_.clear();
	this->finalObjectives_.clear();
	this->initialObjectives_.reserve(MAX_LIST_SIZE);
	this->currentObjectives_.reserve(MAX_LIST_SIZE);
	this->fanoutObjectives_.reserve(MAX_LIST_SIZE);
	this->headLineObjectives_.reserve(MAX_LIST_SIZE);
	this->finalObjectives_.reserve(MAX_LIST_SIZE);
}

// **************************************************************************
// Function   [ Atpg::assignAtpgValToFinalObjectiveGates]
// Commenter  [ WWS ]
// Synopsis   [ usage:
// 								Literal meaning of this function name.
// 							description:
// 								Decide the atpgVal_ of final objective gates by n0 and n1
// 								calculated by previous multiple backtrace.
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
void Atpg::assignAtpgValToFinalObjectiveGates()
{
	while (!this->finalObjectives_.empty())
	{
		Gate &finalObjectiveGate = this->pCircuit_->circuitGates_[vecPop(this->finalObjectives_)];
		// Judge the value by n0 and n1
		if (this->gateID_to_n0_[finalObjectiveGate.gateId_] > this->gateID_to_n1_[finalObjectiveGate.gateId_])
		{
			finalObjectiveGate.atpgVal_ = L;
		}
		else
		{
			finalObjectiveGate.atpgVal_ = H;
		}

		// Put decision of the finalObjective into decisionTree
		this->backtrackDecisionTree_.put(finalObjectiveGate.gateId_, (int)this->backtrackImplicatedGateIDs_.size());
		// Record this gate for backtrack()
		this->backtrackImplicatedGateIDs_.push_back(finalObjectiveGate.gateId_);

		if (this->gateID_to_lineType_[finalObjectiveGate.gateId_] == HEAD_LINE)
		{
			this->gateID_to_valModified_[finalObjectiveGate.gateId_] = 1;
		}
		else
		{
			pushGateToEventStack(finalObjectiveGate.gateId_);
		}
		pushGateFanoutsToEventStack(finalObjectiveGate.gateId_);
	}
}

// **************************************************************************
// Function   [ Atpg::justifyFreeLines ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage: Justify free lines before terminating current
// 								single pattern generation.
//
//              arguments:
// 								[in] originalFault:
// 									The original target fault for current single pattern
// 									generation.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::justifyFreeLines(const Fault &originalFault)
{
	// scan each HEADLINE
	for (const int &headLineGateID : this->headLineGateIDs_)
	{
		Gate *pGate = &this->pCircuit_->circuitGates_[headLineGateID];
		if (pGate->prevAtpgValStored_ == pGate->atpgVal_)
		{
			continue;
		}
		// If the HEADLINE scanned now(pGate) is the new faulty gate
		if (this->currentTargetHeadLineFault_.gateID_ == headLineGateID)
		{
			restoreFault(originalFault);
			continue;
		}
		// For other HEADLINEs, set D or D' to H or L respectively,
		if (pGate->atpgVal_ == D)
		{
			pGate->atpgVal_ = H;
		}
		else if (pGate->atpgVal_ == B)
		{
			pGate->atpgVal_ = L;
		}

		if (!(pGate->gateType_ == Gate::PI || pGate->gateType_ == Gate::PPI || pGate->atpgVal_ == X))
		{
			fanoutFreeBacktrace(pGate);
		}
	}
}

// **************************************************************************
// Function   [ Atpg::restoreFault ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage: Restore the faulty gate to the original position.
//
// 							description: This function is called because when the original
// 								target fault is injected at an gate input, it will then be
// 								modified to equivalent headline fault and set to the
//								corresponding gate.atpgVal_. We need to the revert the
// 								previously mentioned operation for latter algorithm in atpg.
//
//              arguments:
// 								[in] originalFault: The original target fault.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::restoreFault(const Fault &originalFault)
{
	this->fanoutObjectives_.clear();
	this->fanoutObjectives_.reserve(MAX_LIST_SIZE);
	Gate *pOriginalFaultPropGate = &(this->pCircuit_->circuitGates_[originalFault.gateID_]);

	if (originalFault.faultyLine_ == 0)
	{
		this->fanoutObjectives_.push_back(originalFault.gateID_);
	}

	// Restore the free line faults which is at gate input because the faults
	// are all rearranged to equivalent at gate output in previous atpg functions
	for (int faninGateID : pOriginalFaultPropGate->faninVector_)
	{
		Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
		if (faninGate.atpgVal_ == D)
		{
			faninGate.atpgVal_ = H;
		}
		else if (faninGate.atpgVal_ == B)
		{
			faninGate.atpgVal_ = L;
		}

		if (faninGate.atpgVal_ == L || faninGate.atpgVal_ == H)
		{
			this->fanoutObjectives_.push_back(faninGateID);
		}
	}

	// Push original fault gate into this->fanoutObjectives_
	// for each loop, scan all fanin gates of pFaultPropGate (initial to be original fault gate)
	// if fanin gates' value == 0 or 1, add it into this->fanoutObjectives_ list iteratively
	// let pFaultPropGate's output gate (FREE_LINE only have one output gate) be new pFaultPropGate
	// and perform the procedure of each loop till pFaultPropGate is HEADLINE
	if (this->gateID_to_lineType_[originalFault.gateID_] == FREE_LINE)
	{
		while (pOriginalFaultPropGate->numFO_ > 0)
		{
			pOriginalFaultPropGate = &(this->pCircuit_->circuitGates_[pOriginalFaultPropGate->fanoutVector_[0]]);
			for (int faninGateID : pOriginalFaultPropGate->faninVector_)
			{
				const Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
				if (faninGate.atpgVal_ == L || faninGate.atpgVal_ == H)
				{
					this->fanoutObjectives_.push_back(faninGate.gateId_);
				}
			}
			if (this->gateID_to_lineType_[pOriginalFaultPropGate->gateId_] == HEAD_LINE)
			{
				break;
			}
		}
	}
	// Every iteration pop out an element in the this->fanoutObjectives_
	while (!this->fanoutObjectives_.empty())
	{
		Gate *pFanoutObjectiveGate = &(this->pCircuit_->circuitGates_[vecPop(this->fanoutObjectives_)]);

		if (pFanoutObjectiveGate->atpgVal_ == D)
		{
			pFanoutObjectiveGate->atpgVal_ = H;
		}
		else if (pFanoutObjectiveGate->atpgVal_ == B)
		{
			pFanoutObjectiveGate->atpgVal_ = L;
		}

		if (!(pFanoutObjectiveGate->gateType_ == Gate::PI || pFanoutObjectiveGate->gateType_ == Gate::PPI || pFanoutObjectiveGate->atpgVal_ == X)) // if the gate's value not unknown and the gates type not PI or PPI
		{
			fanoutFreeBacktrace(pFanoutObjectiveGate);
		}
	}
}

// **************************************************************************
// Function   [ Atpg::countEffectiveDFrontiers ]
// Commenter  [ WWS ]
// Synopsis   [ usage:
//								Update the this->dFrontiers make sure the d-frontiers in it
// 								are all effective.
// 							Description:
// 								By effective we mean if a d-frontier is able to propagate to
// 								PO/PPO.
//
//              arguments:
// 								[in] originalFault:
// 									The original target fault for current single pattern
// 									generation.
// 							output:
//								The updated this->dFrontier.size()
//            ]
// Date       [ last modified 2023/01/06 ]
// **************************************************************************
int Atpg::countEffectiveDFrontiers(Gate *pFaultyLineGate)
{
	updateDFrontiers();

	// Change the xPathStatus from XPATH_EXIST to UNKNOWN of a gate
	// which has equal or higher level than the faulty gate
	// (the gate array has been given its level already)
	// This is to clear the xPathStatus of previous xPathTracing
	for (int i = pFaultyLineGate->gateId_; i < this->pCircuit_->totalGate_; ++i)
	{
		if (this->gateID_to_xPathStatus_[i] == XPATH_EXIST)
		{
			this->gateID_to_xPathStatus_[i] = UNKNOWN;
		}
	}

	for (int k = (int)(this->dFrontiers_.size()) - 1; k >= 0; --k)
	{
		// if D-frontier can't propagate to the PO, erase it
		if (!xPathTracing(&this->pCircuit_->circuitGates_[this->dFrontiers_[k]]))
		{
			vecDelete(this->dFrontiers_, k);
		}
	}
	return (int)(this->dFrontiers_.size());
}

// **************************************************************************
// Function   [ Atpg::doUniquePathSensitization ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage:	Finds the last gate(pNextGate) in the uniquePath
// 											starts from pGate, return backwardImplicationLevel,
// 											which is the max of the pNextGate's input level.
// 											backwardImplicationLevel is -1 if no uniquePath.
//
// 							description:
// 								First check whether "gate" is the current target fault's
// 								gate. If not, we check the values of its fanin gates.
// 								If the value is unknown, set it to non-control value,
// 								push it into the this->backtrackImplicatedGateIDs,
// 								and call pushInputEvent function for this fanin gate.
// 								backwardImplicationLevel is set to the max of fanin level.
// 								If the value is control value, we return
// 								UNIQUE_PATH_SENSITIZE_FAIL (-2).
// 								Now set the current gate to the input gate and enter the
// 								while loop.
// 								If the current gate is PO/PPO, or it has no
// 								dominators(excluded fanout free), leave the loop.
// 								Then set the next gate to the fanout gate
// 								(for fanout free gate) or its dominator.
// 								Now check whether the non-control value is not unknown
// 								and the gate is not unary.
// 								If false, do nothing, else we have two cases:
// 								fanout-free :
// 									Check the fanin gates of the next gate that is not the
// 									current gate. If its value is the control value,
// 									then return UNIQUE_PATH_SENSITIZE_FAIL. Otherwise if its
// 									value is unknown, set it to non-control value, push it
// 									into the backtrackList_.
// 									BackImpLevel is set to the maximum of fanin level.
// 								not fanout-free :
// 									Check the fanin gates of the next gate.
// 									If it is fault reachable, do nothing
// 									else check its value.
// 										If its value is the control value,
// 											return UNIQUE_PATH_SENSITIZE_FAIL.
// 										Otherwise if its value is unknown,
// 											set it to non-control value,
// 											push it into the backtrackList_,
// 											and call pushInputEvent function for this fanin gate.
// 											BackImpLevel is set to the maximum of fanin level.
// 								Finally, set the current gate to the next gate
// 								and start a new loop.
// 								Return BackImpLevel at last.
//
//              arguments:
// 								[in] gate : The gate to do unique sensitization on.
//
// 							output:
// 								int(backwardImplicationLevel)
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
int Atpg::doUniquePathSensitization(Gate &gate)
{
	int backwardImplicationLevel = NO_UNIQUE_PATH;

	// if gate is not the current target fault gateID
	if (currentTargetFault_.gateID_ != gate.gateId_)
	{
		const Value NonControlVal = gate.getInputNonCtrlValue();
		// if gate has an NonControlVal (1 or 0)
		if (NonControlVal != X)
		{
			for (const int &faninGateID : gate.faninVector_)
			{
				Gate *pFaninGate = &this->pCircuit_->circuitGates_[faninGateID];
				if (pFaninGate->atpgVal_ == X)
				{
					pFaninGate->atpgVal_ = NonControlVal;
					// backwardImplicationLevel becomes MAX of fanin level
					if (backwardImplicationLevel < pFaninGate->numLevel_)
					{
						backwardImplicationLevel = pFaninGate->numLevel_;
					}

					this->backtrackImplicatedGateIDs_.push_back(faninGateID);
					pushGateToEventStack(faninGateID);
					pushGateFanoutsToEventStack(faninGateID);
				}
				else if (pFaninGate->atpgVal_ == gate.getInputCtrlValue())
				{
					return UNIQUE_PATH_SENSITIZE_FAIL;
				}
			}
		}
	}

	Gate *pCurrGate = &gate;
	Gate *pNextGate = NULL;

	while (true)
	{
		std::vector<int> &uniquePathList = this->gateID_to_uniquePath_[pCurrGate->gateId_];

		if (pCurrGate->gateType_ == Gate::PO || pCurrGate->gateType_ == Gate::PPO)
		{
			break;
		}
		else if (pCurrGate->numFO_ == 1) // If pCurrGate is fanout free, set pNextGate to its output gate.
		{
			pNextGate = &(this->pCircuit_->circuitGates_[pCurrGate->fanoutVector_[0]]);
		}
		else if ((int)(uniquePathList.size()) == 0)
		{
			break;
		}
		else
		{
			// set pNextGate to uniquePathList[0].
			pNextGate = &(this->pCircuit_->circuitGates_[uniquePathList[0]]);
		}

		const Value NonControlVal = pNextGate->getInputNonCtrlValue();

		if ((NonControlVal != X) && !(pNextGate->isUnary()))
		{ // If pNextGate is Unary and its NonControlVal is not unknown.
			if (pCurrGate->numFO_ == 1)
			{
				// If gCurrGate(pGate) is fanout free, pNextGate is gCurrGate's output gate.
				// Go through all pNextGate's input.
				for (int faninGateID : pNextGate->faninVector_)
				{
					Gate *pFaninGate = &(this->pCircuit_->circuitGates_[faninGateID]);

					if (pFaninGate != pCurrGate && pNextGate->getInputCtrlValue() != X && pFaninGate->atpgVal_ == pNextGate->getInputCtrlValue())
					{
						return UNIQUE_PATH_SENSITIZE_FAIL;
					}

					if (pFaninGate != pCurrGate && pFaninGate->atpgVal_ == X)
					{
						pFaninGate->atpgVal_ = NonControlVal; // Set input gate of pNextGate to pNextGate's NonControlVal
						if (backwardImplicationLevel < pFaninGate->numLevel_)
						{
							backwardImplicationLevel = pFaninGate->numLevel_;
						}
						// backwardImplicationLevel becomes MAX of pNextGate's fanin level
						this->backtrackImplicatedGateIDs_.push_back(faninGateID);
						pushGateToEventStack(faninGateID);
						pushGateFanoutsToEventStack(faninGateID);
					}
				}
			}
			else
			{ // *pCurrGate is has more than one fanout, pNextGate is uniquePathList[0].

				bool dependOnCurrent;
				for (int faninGateID : pNextGate->faninVector_)
				{
					// Go through all pNextGate's input.
					Gate *pFaninGate = &this->pCircuit_->circuitGates_[faninGateID];
					dependOnCurrent = false;

					for (int j = 1; j < (int)(uniquePathList.size()); ++j)
					{
						if (uniquePathList[j] == faninGateID)
						{
							dependOnCurrent = true;
							break;
						}
					}

					if (!dependOnCurrent)
					{
						if (pFaninGate->atpgVal_ != X && pFaninGate->atpgVal_ == pNextGate->getInputCtrlValue() && pNextGate->getInputCtrlValue() != X)
						{
							return UNIQUE_PATH_SENSITIZE_FAIL;
						}

						if (pFaninGate->atpgVal_ != X)
						{
							continue;
						}

						pFaninGate->atpgVal_ = NonControlVal;

						// backwardImplicationLevel becomes MAX of pNextGate's fanin level
						if (backwardImplicationLevel < pFaninGate->numLevel_)
						{
							backwardImplicationLevel = pFaninGate->numLevel_;
						}
						this->backtrackImplicatedGateIDs_.push_back(faninGateID);
						pushGateToEventStack(faninGateID);
						pushGateFanoutsToEventStack(faninGateID);
					}
				}
			}
		}
		// move to last gate in this->gateID_to_uniquePath_
		pCurrGate = pNextGate;
	}
	return backwardImplicationLevel;
}

// **************************************************************************
// Function   [ Atpg::xPathExists ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
// 								Use to determine if xpath exist for "gate".
//
// 							description:
//                Used before generateSinglePatternOnTargetFault
//                Return true if there is X-path.
//                Otherwise, return false.
//
//              arguments:
// 								[in] gate:
// 									The gate to see if xpath exists.
//
//              output:
// 								A boolean indicating if the x path exists.
//            ]
// Date       [ started 2020/07/07    last modified 2023/01/06 ]
// **************************************************************************
bool Atpg::xPathExists(Gate *pGate)
{
	// TODO: This part can be implemented by event-driven method
	// Clear the this->gateID_to_xPathStatus_ from target gate to PO/PPO
	for (int i = pGate->gateId_; i < this->pCircuit_->totalGate_; ++i)
	{
		this->gateID_to_xPathStatus_[i] = UNKNOWN;
	}
	return xPathTracing(pGate);
}

// **************************************************************************
// Function   [ Atpg::xPathTracing ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage:
// 								Use to determine if xpath exist for "gate".
//
// 							description:
// 								recursive call the function itself with the fanout of
//								original pGate until PO/PPO is reached and check if
// 								pGate has a X path
//
//              arguments:
// 								[in] gate:
// 									The gate to see if xpath exists.
//
//              output:
// 								A boolean indicating if the x path exists.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
bool Atpg::xPathTracing(Gate *pGate)
{
	if ((pGate->atpgVal_ != X) || (this->gateID_to_xPathStatus_[pGate->gateId_] == NO_XPATH_EXIST))
	{
		this->gateID_to_xPathStatus_[pGate->gateId_] = NO_XPATH_EXIST;
		return false;
	}

	if (this->gateID_to_xPathStatus_[pGate->gateId_] == XPATH_EXIST)
	{
		return true;
	}

	if (pGate->gateType_ == Gate::PO || pGate->gateType_ == Gate::PPO)
	{
		this->gateID_to_xPathStatus_[pGate->gateId_] = XPATH_EXIST;
		return true;
	}

	for (const int &fanoutGateID : pGate->fanoutVector_)
	{
		// TO-DO homework 03
		if (xPathTracing(&(this->pCircuit_->circuitGates_[fanoutGateID])))
		{
			this->gateID_to_xPathStatus_[pGate->gateId_] = XPATH_EXIST;
			return true;
		}
		// end of TO-DO
	}
	this->gateID_to_xPathStatus_[pGate->gateId_] = NO_XPATH_EXIST;
	return false;
}

// **************************************************************************
// Function   [ Atpg::setFaultyGate ]
// Commenter  [ WYH WWS ]
// Synopsis   [ usage: Initial assignment of fault signal.
//                     There are two situations :
//                     1. Fault is on the input line of pFaultyGate, and
//                        pFaultyLineGate is the fanin gate of pFaultyGate
//                       (1) Activate the fault, and set value of pFaultyLineGate
//                           according to fault type.
//                       (2) According to the type of pFaultyGate, set other fanin
//                           gate of pFaultyGate to NoneControlling value of
//                           pFaultyGate, and set value of pFaultyGate.
//                       (3) Schedule all fanout gates of fanin gates of pFaultyGate,
//                           and schedule fanout gates of pFaultyGate.
//                       (4) Update backwardImplicationLevel to be maximum level of
//                           fanin gates of pFaultyGate.
//                     2. Fault is on the ouput line of pFaultyGate, and
//                        pFaultyLineGate is pFaultyGate.
//                       (1) Activate the fault, and set value of pFaultyLineGate
//                           according to fault type.
//                       (2) Schedule fanout gates of pFaultyGate.
//                       (3) If pFaultyGate is a HEADLINE, all it's fanin gates are
//                           FREE_LINE, no need to set value.
//                           Else, set the value of it's fanin gates, and schedule
//                           all fanout gates of fanin gates of pFaultyGate.
//                       (4) Update backwardImplicationLevel to be maximum level of
//                           fanin gates of pFaultyGate.
//              arguments:
//								[in] fault: The fault for setting value to gate.
//              out:   int backwardImplicationLevel: The backwardImplicationLevel indicates the backward
//                     imply level return -1 when fault FAULT_UNTESTABLE
//            ]
// Date       [ WYH Ver. 1.0 started 2013/08/16 last modified 2023/01/06 ]
// **************************************************************************
int Atpg::setFaultyGate(Fault &fault)
{
	Value valueTemp;
	Gate *pFaultyGate = NULL;
	Gate *pFaultyLineGate = NULL;
	int backwardImplicationLevel = 0;
	const bool faultIsAtGateOutput = (fault.faultyLine_ == 0);
	// if the fault is SA0 or STR, then set faulty value to D (1/0)
	Value faultyVal = (fault.faultType_ == Fault::SA0 || fault.faultType_ == Fault::STR) ? D : B;

	pFaultyGate = &(this->pCircuit_->circuitGates_[fault.gateID_]);
	// if the fault is input fault, the pFaultyLineGate is decided by fault.faultyLine_
	// else pFaultyLineGate is pFaultyGate
	if (!faultIsAtGateOutput)
	{
		pFaultyLineGate = &(this->pCircuit_->circuitGates_[pFaultyGate->faninVector_[fault.faultyLine_ - 1]]);
	}
	else
	{
		pFaultyLineGate = pFaultyGate;
	}

	if (!faultIsAtGateOutput)
	{
		if (faultyVal == D && pFaultyLineGate->atpgVal_ != L)
		{
			pFaultyLineGate->atpgVal_ = H;
		}
		else if (faultyVal == B && pFaultyLineGate->atpgVal_ != H)
		{
			pFaultyLineGate->atpgVal_ = L;
		}
		else
		{ // The fault can not propagate to PO
			return -1;
		}

		this->backtrackImplicatedGateIDs_.push_back(pFaultyLineGate->gateId_);

		bool isFaultyGateScanned;
		switch (pFaultyGate->gateType_)
		{
			case Gate::AND2:
			case Gate::AND3:
			case Gate::AND4:
			case Gate::NAND2:
			case Gate::NAND3:
			case Gate::NAND4:
			case Gate::OR2:
			case Gate::OR3:
			case Gate::OR4:
			case Gate::NOR2:
			case Gate::NOR3:
			case Gate::NOR4:
				isFaultyGateScanned = false;
				// scan all fanin gate of pFaultyGate
				for (int faninGateID : pFaultyGate->faninVector_)
				{
					Gate *pFaninGate = &this->pCircuit_->circuitGates_[faninGateID];
					if (pFaninGate != pFaultyLineGate)
					{
						if (pFaninGate->atpgVal_ == X)
						{
							pFaninGate->atpgVal_ = pFaultyGate->getInputNonCtrlValue();
							this->backtrackImplicatedGateIDs_.push_back(faninGateID);
						}
						else if (pFaninGate->atpgVal_ != pFaultyGate->getInputNonCtrlValue())
						{
							// If the value has already been set, it should be
							// non-control value, otherwise the fault can't propagate
							return -1;
						}
					}
					else
					{
						if (isFaultyGateScanned == false)
						{
							isFaultyGateScanned = true;
						}
						else
						{
							return -1; // FAULT_UNTESTABLE
						}
					}
				}
				valueTemp = pFaultyGate->isInverse();
				// find the pFaultyGate output value
				pFaultyGate->atpgVal_ = cXOR2(valueTemp, faultyVal);
				this->backtrackImplicatedGateIDs_.push_back(pFaultyGate->gateId_);
				break;
			case Gate::INV:
			case Gate::BUF:
			case Gate::PO:
			case Gate::PPO:
				valueTemp = pFaultyGate->isInverse();
				pFaultyGate->atpgVal_ = cXOR2(valueTemp, faultyVal);
				this->backtrackImplicatedGateIDs_.push_back(pFaultyGate->gateId_);
				break;
		}

		if (pFaultyGate->atpgVal_ != X)
		{
			// schedule all the fanout gate of pFaultyGate
			pushGateFanoutsToEventStack(pFaultyGate->gateId_);
			this->gateID_to_valModified_[pFaultyGate->gateId_] = 1;
		}

		for (int faninGateID : pFaultyGate->faninVector_)
		{
			Gate *pFaninGate = &(this->pCircuit_->circuitGates_[faninGateID]);
			if (pFaninGate->atpgVal_ != X)
			{
				// set the backwardImplicationLevel to be maximum of fanin gate's level
				if (backwardImplicationLevel < pFaninGate->numLevel_)
				{
					backwardImplicationLevel = pFaninGate->numLevel_;
				}
				// schedule all fanout gates of the fanin gate
				pushGateToEventStack(faninGateID);
				pushGateFanoutsToEventStack(faninGateID);
			}
		}
	}
	else
	{ // output fault
		if ((faultyVal == D && pFaultyGate->atpgVal_ == L) || (faultyVal == B && pFaultyGate->atpgVal_ == H))
		{
			return -1;
		}
		pFaultyGate->atpgVal_ = faultyVal;
		this->backtrackImplicatedGateIDs_.push_back(pFaultyGate->gateId_);
		// schedule all of fanout gate of the pFaultyGate
		pushGateFanoutsToEventStack(pFaultyGate->gateId_);
		// backtrace stops at HEAD LINE
		if (this->gateID_to_lineType_[pFaultyGate->gateId_] == HEAD_LINE)
		{
			this->gateID_to_valModified_[pFaultyGate->gateId_] = 1;
		}
		else if (pFaultyGate->gateType_ == Gate::INV || pFaultyGate->gateType_ == Gate::BUF || pFaultyGate->gateType_ == Gate::PO || pFaultyGate->gateType_ == Gate::PPO)
		{
			Gate &faninGate = this->pCircuit_->circuitGates_[pFaultyGate->faninVector_[0]];
			this->gateID_to_valModified_[pFaultyGate->gateId_] = 1;

			Value Val = (faultyVal == D) ? H : L;
			Value valueTemp = pFaultyGate->isInverse();
			faninGate.atpgVal_ = cXOR2(valueTemp, Val);
			this->backtrackImplicatedGateIDs_.push_back(faninGate.gateId_);
			pushGateToEventStack(faninGate.gateId_);
			pushGateFanoutsToEventStack(faninGate.gateId_);

			if (backwardImplicationLevel < faninGate.numLevel_)
			{
				backwardImplicationLevel = faninGate.numLevel_;
			}
		}
		else if ((faultyVal == D && pFaultyGate->getOutputCtrlValue() == H) || (faultyVal == B && pFaultyGate->getOutputCtrlValue() == L))
		{
			this->gateID_to_valModified_[pFaultyGate->gateId_] = 1;
			for (int faninGateID : pFaultyGate->faninVector_)
			{
				Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
				if (faninGate.atpgVal_ == X)
				{
					faninGate.atpgVal_ = pFaultyGate->getInputNonCtrlValue();
					this->backtrackImplicatedGateIDs_.push_back(faninGateID);
					// schedule all fanout gate of the faninGate
					pushGateToEventStack(faninGateID);
					pushGateFanoutsToEventStack(faninGateID);
					if (backwardImplicationLevel < faninGate.numLevel_)
					{
						backwardImplicationLevel = faninGate.numLevel_;
					}
				}
			}
		}
		else
		{
			pushGateToEventStack(pFaultyGate->gateId_);
			if (backwardImplicationLevel < pFaultyGate->numLevel_)
			{
				backwardImplicationLevel = pFaultyGate->numLevel_;
			}
		}
	}
	return backwardImplicationLevel;
}

// **************************************************************************
// Function   [ Atpg::setFreeLineFaultyGate ]
// Commenter  [ WYH WWS ]
// Synopsis   [ usage:
//								Set equivalent fault according to the faulty gate.
//
// 							description:
// 								This function is called when gate is FREE_LINE.
//                That means it has only one output gate.
//                The returned fault must be on the output line of its gateID.
//                In the while loop, sets unknown fanin gate of pCurrentGate
//                to non-control value of pCurrentGate and sets the value of
//                pCurrentGate.
//                The loop breaks when pCurrentGate becomes a HEADLINE.
//                When pCurrentGate is a HEADLINE, this function schedules
//                all fanout gate of pCurrentGate, and decides the new
//                fault type according to the value of pCurrentGate
//                and returns the new fault.
//
//              arguments:
// 								[in] gate:
// 									The faulty gate.
//
//              output:
// 								The new head line fault that is equivalent to the original
// 								free line fault.
//            ]
// Date       [ WYH Ver. 1.0 started 2013/08/17 2023/01/06 ]
// **************************************************************************
Fault Atpg::setFreeLineFaultyGate(Gate &gate)
{
	int currGateID = 0;
	Gate *pCurrentGate = NULL;
	std::stack<int> tempStack;
	tempStack.push(gate.fanoutVector_[0]);

	while (!tempStack.empty())
	{
		currGateID = tempStack.top();
		tempStack.pop();
		pCurrentGate = &(this->pCircuit_->circuitGates_[currGateID]);
		Value currGateInputNonCtrlVal = pCurrentGate->getInputNonCtrlValue();
		if (currGateInputNonCtrlVal == X)
		{
			currGateInputNonCtrlVal = L;
		}
		for (int faninGateID : pCurrentGate->faninVector_)
		{
			Gate &faninGate = this->pCircuit_->circuitGates_[faninGateID];
			// set pCurrentGate unknown fanin gate to non-control value
			if (faninGate.atpgVal_ == X)
			{
				faninGate.atpgVal_ = currGateInputNonCtrlVal;
				this->backtrackImplicatedGateIDs_.push_back(faninGateID);
			}
		}

		if (pCurrentGate->atpgVal_ == X)
		{
			// set the value of pCurrentGate by evaluateGoodVal
			pCurrentGate->atpgVal_ = evaluateGoodVal(*pCurrentGate);
			this->backtrackImplicatedGateIDs_.push_back(currGateID);
		}
		// if the pCurrentGate is FREE LINE,
		// pCurrentGate output gate becomes a new pCurrentGate
		// until pCurrentGate becomes HEAD LINE
		if (this->gateID_to_lineType_[currGateID] == FREE_LINE)
		{
			tempStack.push(pCurrentGate->fanoutVector_[0]);
		}
	}
	this->gateID_to_valModified_[currGateID] = 1;
	pushGateFanoutsToEventStack(currGateID);
	// decide the new fault type according to pCurrentGate value
	return Fault(currGateID, (pCurrentGate->atpgVal_ == D) ? Fault::SA0 : Fault::SA1, 0);
}

// **************************************************************************
// Function   [ Atpg::fanoutFreeBacktrace ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage: Backtrace in Fanout Free situation
//              arguments:
//								[in] pGate:
// 									The gate to start performing fanout free backtrace.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06]
// **************************************************************************
void Atpg::fanoutFreeBacktrace(Gate *pGate)
{
	this->currentObjectives_.clear();
	this->currentObjectives_.reserve(MAX_LIST_SIZE);
	this->currentObjectives_.push_back(pGate->gateId_);

	while (!this->currentObjectives_.empty())
	{
		Gate *pGate = &(this->pCircuit_->circuitGates_[vecPop(this->currentObjectives_)]);

		if (pGate->gateType_ == Gate::PI || pGate->gateType_ == Gate::PPI || pGate == this->firstTimeFrameHeadLine_)
		{
			continue;
		}

		Value pGateIsInverse = pGate->isInverse();

		if (pGate->gateType_ == Gate::XOR2 || pGate->gateType_ == Gate::XNOR2)
		{
			if (&(this->pCircuit_->circuitGates_[pGate->faninVector_[1]]) != this->firstTimeFrameHeadLine_)
			{
				if (this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ == X)
				{
					this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ = L;
				}
				this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_ = cXOR3(pGate->atpgVal_, pGate->isInverse(), this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_);
			}
			else
			{
				this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ = cXOR3(pGate->atpgVal_, pGate->isInverse(), this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_);
			}
			this->currentObjectives_.push_back(pGate->faninVector_[0]);
			this->currentObjectives_.push_back(pGate->faninVector_[1]);
		}
		else if (pGate->gateType_ == Gate::XOR3 || pGate->gateType_ == Gate::XNOR3)
		{
			if (&(this->pCircuit_->circuitGates_[pGate->faninVector_[1]]) != this->firstTimeFrameHeadLine_)
			{
				if (this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ == X)
				{
					this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ = L;
				}
				if (this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_ == X)
				{
					this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_ = L;
				}
				this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_ = cXOR3(cXOR2(pGate->atpgVal_, pGate->isInverse()), this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_, this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_);
			}
			else
			{
				this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ = L;
				this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_ = cXOR3(cXOR2(pGate->atpgVal_, pGate->isInverse()), this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_, this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_);
			}
			this->currentObjectives_.push_back(pGate->faninVector_[0]);
			this->currentObjectives_.push_back(pGate->faninVector_[1]);
			this->currentObjectives_.push_back(pGate->faninVector_[2]);
		}
		else if (pGate->isUnary())
		{ // if pGate only have one input gate
			if (&(this->pCircuit_->circuitGates_[pGate->faninVector_[0]]) != this->firstTimeFrameHeadLine_)
			{
				this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_ = cXOR2(pGate->atpgVal_, pGateIsInverse);
			}
			this->currentObjectives_.push_back(pGate->faninVector_[0]);
		}
		else
		{
			Value Val = cXOR2(pGate->atpgVal_, pGateIsInverse);
			if (Val == pGate->getInputCtrlValue())
			{
				Gate *pMinLevelGate = &this->pCircuit_->circuitGates_[pGate->minLevelOfFanins_];
				if (pMinLevelGate != this->firstTimeFrameHeadLine_)
				{
					pMinLevelGate->atpgVal_ = Val;
					this->currentObjectives_.push_back(pMinLevelGate->gateId_);
				}
				else
				{
					Gate *pFaninGate = NULL;
					for (int i = 0; i < pGate->numFI_; ++i)
					{
						pFaninGate = &this->pCircuit_->circuitGates_[pGate->faninVector_[i]];
						if (pFaninGate != this->firstTimeFrameHeadLine_)
						{
							break;
						}
					}
					pFaninGate->atpgVal_ = Val;
					this->currentObjectives_.push_back(pFaninGate->gateId_);
				}
			}
			else
			{
				Gate *pFaninGate = NULL;
				for (int i = 0; i < pGate->numFI_; ++i)
				{
					pFaninGate = &this->pCircuit_->circuitGates_[pGate->faninVector_[i]];
					if (pFaninGate->atpgVal_ == X)
					{
						pFaninGate->atpgVal_ = Val;
					}
					this->currentObjectives_.push_back(pFaninGate->gateId_);
				}
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::multipleBacktrace ]
// Commenter  [ CKY WWS ]
// Synopsis   [ usage: return NO_CONTRADICTORY or CONTRADICTORY after backtrace
//                     see paper P.4 P.5 and Fig.8 for detail information
// 							arguments:
// 								[in] atpgStatus:
//										it have 2 possibilities,
//                    atpgStatus == INITIAL means Multiple Backtrace from the
//                    set of initial objectives
//                    atpgStatus == FAN_OBJ_DETERMINE means Multiple Backtrace
//                    from the set of Fanout-Point Objectives
// 								[out] possibleFinalObjectiveID:
// 										Reference of possible fanout objective in current
// 										single pattern generation.
//              output:	BACKTRACE_RESULT
//											return CONTRADICTORY when we find a
//                      Fanout-Point Objective that is not reachable from
//                      the fault line and n0, n1 of it are both not zero;
//                      otherwise, return NO_CONTRADICTORY
//                       n0 is the number of times objective 0 is required,
//                       n1 is the number of times objective 1 is required
//            ]
// Date       [ CKY Ver. 1.0 commented 2013/08/17 last modified 2023/01/06 ]
// **************************************************************************
Atpg::BACKTRACE_RESULT Atpg::multipleBacktrace(BACKTRACE_STATUS atpgStatus, int &possibleFinalObjectiveID)
{
	int n0, n1, new_n0, new_n1;
	Gate *pCurrentObjGate = NULL;

	if (atpgStatus == INITIAL)
	{
		initializeForMultipleBacktrace();
		// Get ready to get into the following while loop
		atpgStatus = CHECK_AND_SELECT;
	}

	while (true)
	{
		Gate *pEasiestFaninGate = NULL;
		switch (atpgStatus)
		{
			case CHECK_AND_SELECT:
				if (this->currentObjectives_.empty())
				{
					if (this->fanoutObjectives_.empty())
					{
						return NO_CONTRADICTORY;
					}
					else
					{
						atpgStatus = FAN_OBJ_DETERMINE;
					}
				}
				else
				{
					// pop from current objectives
					pCurrentObjGate = &(this->pCircuit_->circuitGates_[vecPop(this->currentObjectives_)]);
					atpgStatus = CURRENT_OBJ_DETERMINE;
				}
				break;
			case CURRENT_OBJ_DETERMINE:
				// IS OBJECTIVE LINE A HEAD LINE?
				if (this->gateID_to_lineType_[pCurrentObjGate->gateId_] == HEAD_LINE)
				{
					// ADD THE CURRENT OBJECTIVE TO THE SET OF HEAD OBJECTIVES
					this->headLineObjectives_.push_back(pCurrentObjGate->gateId_);
				}
				else
				{
					// get Val, no and n1 of pCurrentObjGate
					Value Val = assignBacktraceValue(n0, n1, *pCurrentObjGate);

					// the easiest gate to control value to Val
					pEasiestFaninGate = findEasiestFaninGate(pCurrentObjGate, Val);

					// add next objectives to current objectives and
					// calculate n0, n1 by rule1~rule6
					// rule1~rule6:[Reference paper p4, p5 Fig6
					for (int faninGateID : pCurrentObjGate->faninVector_)
					{
						// go through all fan in gate of pCurrentObjGate
						Gate *pFaninGate = &this->pCircuit_->circuitGates_[faninGateID];

						// ignore the fanin gate that already has value determined
						if (pFaninGate->atpgVal_ != X)
						{
							continue;
						}

						// DOES OBJECTIVE LINE FOLLOW A FANOUT-POINT?
						if (pFaninGate->numFO_ > 1)
						{ // YES
							// rule 1 ~ rule 5
							if (pFaninGate == pEasiestFaninGate)
							{
								new_n0 = n0;
								new_n1 = n1;
							}
							else if (Val == L)
							{
								new_n0 = 0;
								new_n1 = n1;
							}
							else if (Val == H)
							{
								new_n0 = n0;
								new_n1 = 0;
							}
							else
							{
								if (n0 > n1)
								{
									new_n0 = n0;
									new_n1 = n1;
								}
								else
								{
									new_n0 = n1;
									new_n1 = n0;
								}
							}

							if (new_n0 > 0 || new_n1 > 0)
							{
								// first find this fanout point, add to
								// Fanout-Point Objectives set
								if (this->gateID_to_n0_[faninGateID] == 0 && this->gateID_to_n1_[faninGateID] == 0)
								{
									this->fanoutObjectives_.push_back(faninGateID);
								}

								// new value = old value(this->gateID_to_n0_(),this->gateID_to_n1_()) + this branch's value (new_n0, new_nn1)
								// rule6: fanout point's n0, n1 = sum of it's branch's no, n1
								setGaten0n1(faninGateID, this->gateID_to_n0_[faninGateID] + new_n0, this->gateID_to_n1_[faninGateID] + new_n1);
								this->gateIDsToResetAfterBackTrace_.push_back(faninGateID);
							}
						}
						else
						{
							// rule 1 ~ rule 5
							if (pFaninGate == pEasiestFaninGate)
							{
								new_n0 = n0;
								new_n1 = n1;
							}
							else if (Val == L)
							{
								new_n0 = 0;
								new_n1 = n1;
							}
							else if (Val == H)
							{
								new_n0 = n0;
								new_n1 = 0;
							}
							else
							{
								if (n0 > n1)
								{
									new_n0 = n0;
									new_n1 = n1;
								}
								else
								{
									new_n0 = n1;
									new_n1 = n0;
								}
							}

							if (new_n0 > 0 || new_n1 > 0)
							{
								// add gate into Current Objective set
								// BY THE RULES(1)-(5) DETERMINE NEXT OBJECTIVES
								// AND ADD THEM TO THE SET OF CURRENT OBJECTIVES
								setGaten0n1(faninGateID, new_n0, new_n1);
								this->gateIDsToResetAfterBackTrace_.push_back(faninGateID);
								this->currentObjectives_.push_back(faninGateID);
							}
						}
					}
				}
				atpgStatus = CHECK_AND_SELECT;
				break;

			case FAN_OBJ_DETERMINE:
				int index;
				pCurrentObjGate = findClosestToPO(this->fanoutObjectives_, index);

				vecDelete(this->fanoutObjectives_, index);

				// if value of pCurrent is not X
				// ignore the Fanout-Point Objective that already set value
				if (pCurrentObjGate->atpgVal_ != X)
				{
					atpgStatus = CHECK_AND_SELECT;
					break;
				}

				if (this->gateID_to_reachableByTargetFault_[pCurrentObjGate->gateId_] == 1)
				{
					atpgStatus = CURRENT_OBJ_DETERMINE;
					break;
				}

				// if one of numOfZero or numOfOne is equal to 0
				if (!(this->gateID_to_n0_[pCurrentObjGate->gateId_] != 0 && this->gateID_to_n1_[pCurrentObjGate->gateId_] != 0))
				{
					atpgStatus = CURRENT_OBJ_DETERMINE;
					break;
				}

				// if three conditions are not set up, then push back pCurrentObjGate to finalObject
				// then terminate Multiple Backtrace procedure
				// when "a Fanout-Point objective is not reachable from the
				// fault line" and "both no, n1 of it are nonzero "
				// return CONTRADICTORY in this situation
				// Let the Fanout-Point objective to be a Final Objective
				possibleFinalObjectiveID = pCurrentObjGate->gateId_;
				return CONTRADICTORY;

			default:
				break;
		}
	}
	// after breaking while loop
	return NO_CONTRADICTORY;
}

// **************************************************************************
// Function   [ Atpg::assignBacktraceValue ]
// Commenter  [ CKY WWS ]
// Synopsis   [ usage:	help to get n0 n1 and Value depend on
// 											Gate's controlling value
//              arguments:
// 								[out] n0:	n0 (int reference) to be set
// 								[out] n1: n1 (int reference) to be set
// 								[in] gate:
// 									gate to assign backtrace value to but the gate.atpgVal_
// 									is assigned outside this function
//              out:   Value, n0, n1
//            ]
// Date       [ CKY Ver. 1.0 commented 2013/08/17 last modified 2023/01/06 ]
// **************************************************************************
Value Atpg::assignBacktraceValue(int &n0, int &n1, const Gate &gate)
{
	Value tempVal;
	int numOfFaninIs1 = 0;
	switch (gate.gateType_)
	{
		// when gate is AND type,n0 = numOfZero,n1 = numOfOne
		case Gate::AND2:
		case Gate::AND3:
		case Gate::AND4:
			n0 = this->gateID_to_n0_[gate.gateId_];
			n1 = this->gateID_to_n1_[gate.gateId_];
			return L;

		// when gate is OR type,n0 = numOfZero,n1 = numOfOne
		case Gate::OR2:
		case Gate::OR3:
		case Gate::OR4:
			// TO-DO homework 04
			n0 = this->gateID_to_n0_[gate.gateId_];
			n1 = this->gateID_to_n1_[gate.gateId_];
			return H;
			// end of TO-DO

		// when gate is NAND type,n0 = numOfOne,n1 = numOfZero
		case Gate::NAND2:
		case Gate::NAND3:
		case Gate::NAND4:
			n0 = this->gateID_to_n1_[gate.gateId_];
			n1 = this->gateID_to_n0_[gate.gateId_];
			return L;

		// when gate is NOR type,n0 = numOfOne,n1 = numOfZero
		case Gate::NOR2:
		case Gate::NOR3:
		case Gate::NOR4:
			// TO-DO homework 04
			n0 = this->gateID_to_n1_[gate.gateId_];
			n1 = this->gateID_to_n0_[gate.gateId_];
			return H;
			// end of TO-DO

		// when gate is inverter,n0 = numOfOne,n1 = numOfZero
		case Gate::INV:
			n0 = this->gateID_to_n1_[gate.gateId_];
			n1 = this->gateID_to_n0_[gate.gateId_];
			return X;

		// when gate is XOR2 or XNOR2
		case Gate::XOR2:
		case Gate::XNOR2:
			tempVal = this->pCircuit_->circuitGates_[gate.faninVector_[0]].atpgVal_;
			if (tempVal == X)
			{
				tempVal = this->pCircuit_->circuitGates_[gate.faninVector_[1]].atpgVal_;
			}

			if (tempVal == H)
			{
				n0 = this->gateID_to_n1_[gate.gateId_];
				n1 = this->gateID_to_n0_[gate.gateId_];
			}
			else
			{
				n0 = this->gateID_to_n0_[gate.gateId_];
				n1 = this->gateID_to_n1_[gate.gateId_];
			}

			if (gate.gateType_ == Gate::XNOR2)
			{
				std::swap(n0, n1);
			}
			return X;

		// when gate is XOR3 or XNOR3
		case Gate::XOR3:
		case Gate::XNOR3:
			for (int faninGateID : gate.faninVector_)
			{
				if (this->pCircuit_->circuitGates_[faninGateID].atpgVal_ == H)
				{
					++numOfFaninIs1;
				}
			}
			if (numOfFaninIs1 == 2)
			{
				n0 = this->gateID_to_n1_[gate.gateId_];
				n1 = this->gateID_to_n0_[gate.gateId_];
			}
			else
			{
				n0 = this->gateID_to_n0_[gate.gateId_];
				n1 = this->gateID_to_n1_[gate.gateId_];
			}

			if (gate.gateType_ == Gate::XNOR3)
			{
				std::swap(n0, n1);
			}
			return X;
		default:
			n0 = this->gateID_to_n0_[gate.gateId_];
			n1 = this->gateID_to_n1_[gate.gateId_];
			return X;
	}
}

// **************************************************************************
// Function   [ Atpg::initializeForMultipleBacktrace ]
// Commenter  [ CKY WWS ]
// Synopsis   [ usage: initialize all this->gateID_to_n0_ this->gateID_to_n1_
// 							description:
// 								Copy the initial objectives into current objectives.
// 								Traverse all gate in current objectives
// 								If gate's atpgVal_ is L or B
// 									n0 = 1, n1 = 0
// 								Else if gates's atpgVal_ is H pr D
// 									n1 = 0, n0 = 1
// 								Else if X, Z, I
// 									set line number depend on gate type
//
//            ]
// Date       [ CKY Ver. 1.0 commented 2013/08/17 last modified 2023/01/06 ]
// **************************************************************************
void Atpg::initializeForMultipleBacktrace()
{
	this->currentObjectives_ = this->initialObjectives_;

	for (const int &currentObjectGateID : this->currentObjectives_)
	{
		const Gate &currObjGate = this->pCircuit_->circuitGates_[currentObjectGateID];

		if (currObjGate.atpgVal_ == L || currObjGate.atpgVal_ == B)
		{
			setGaten0n1(currentObjectGateID, 1, 0);
		}
		else if (currObjGate.atpgVal_ == H || currObjGate.atpgVal_ == D)
		{
			setGaten0n1(currentObjectGateID, 0, 1);
		}
		else
		{
			switch (currObjGate.gateType_)
			{
				case Gate::AND2:
				case Gate::AND3:
				case Gate::AND4:
				case Gate::NOR2:
				case Gate::NOR3:
				case Gate::NOR4:
				case Gate::XNOR2:
				case Gate::XNOR3:
					setGaten0n1(currentObjectGateID, 0, 1);
					break;
				case Gate::OR2:
				case Gate::OR3:
				case Gate::OR4:
				case Gate::NAND2:
				case Gate::NAND3:
				case Gate::NAND4:
				case Gate::XOR2:
				case Gate::XOR3:
					setGaten0n1(currentObjectGateID, 1, 0);
					break;
				default:
					break;
			}
		}
		this->gateIDsToResetAfterBackTrace_.push_back(currentObjectGateID);
	}
}

// **************************************************************************
// Function   [ Atpg::findEasiestFaninGate ]
// Commenter  [ KOREAL WWS ]
// Synopsis   [ usage: find the EasiestInput by gate::cc0_ or gate::cc1_
// 							description:
// 								Utilize SCOAP heuristic if addSCOAP is called in
// 								setupCircuitParameter(),
// 								Otherwise cc0_ and cc1_ is 0
// 								SCOAP heuristic is finished and can be found in atpg.cpp
// 								but is not included in the algorithm because the result
// 								of SCOAP is even worse.
// 							arguments:
// 								[in] pGate:
// 									The gate to find easiest fanin gate.
//								[out] vak
//              output: the easiest fanin gate to assign value
//            ]
// Date       [ CPJ Ver. 1.0 started 2013/08/10 last modified 2023/01/06]
// **************************************************************************
Gate *Atpg::findEasiestFaninGate(Gate *pGate, const Value &atpgValOfpGate)
{
	Gate *pRetGate = NULL;
	int easyControlVal = INFINITE;

	if (pGate->gateType_ == Gate::PO || pGate->gateType_ == Gate::PPO ||
			pGate->gateType_ == Gate::BUF || pGate->gateType_ == Gate::INV)
	{
		return &(this->pCircuit_->circuitGates_[pGate->faninVector_[0]]);
	}

	if (atpgValOfpGate == L)
	{
		// choose the value-undetermined faninGate which has smallest cc0_
		for (const int &faninGateID : pGate->faninVector_)
		{
			Gate *pFaninGate = &(this->pCircuit_->circuitGates_[faninGateID]);
			if (pFaninGate->atpgVal_ != X)
			{
				continue;
			}

			if (pFaninGate->cc0_ < easyControlVal)
			{
				easyControlVal = pFaninGate->cc0_;
				pRetGate = pFaninGate;
			}
		}
	}
	else
	{
		// choose the value-undetermined faninGate which has smallest cc1_
		for (const int &faninGateID : pGate->faninVector_)
		{
			Gate *pFaninGate = &(this->pCircuit_->circuitGates_[faninGateID]);
			if (pFaninGate->atpgVal_ != X)
			{
				continue;
			}

			if (pFaninGate->cc1_ < easyControlVal)
			{
				easyControlVal = pFaninGate->cc1_;
				pRetGate = pFaninGate;
			}
		}
	}
	return pRetGate;
}

// **************************************************************************
// Function   [ Atpg::findClosestToPO ]
// Commenter  [ CLT WWS ]
// Synopsis   [ usage:
// 								Find the gate which is the closest to output.
// 							arguments:
// 								[in] gateVec:
// t									The gate vector to search.
// 								[out] index:
// 									The index of the gate closest to PO/PPO.
//              output:
// 								The gate which is closest to output.
//            ]
// Date       [ Ver. 1.0 started 2013/08/13 last modified 2023/01/06 ]
// **************************************************************************
Gate *Atpg::findClosestToPO(std::vector<int> &gateVec, int &index)
{
	Gate *pClosestGate = NULL;

	if (gateVec.empty())
	{
		return NULL;
	}

	pClosestGate = &(this->pCircuit_->circuitGates_[gateVec.back()]);
	index = gateVec.size() - 1;
	for (int i = gateVec.size() - 2; i >= 0; --i)
	{
		if (this->pCircuit_->circuitGates_[gateVec[i]].depthFromPo_ < pClosestGate->depthFromPo_)
		{
			index = i;
			pClosestGate = &this->pCircuit_->circuitGates_[gateVec[i]];
		}
	}
	return pClosestGate;
}

// **************************************************************************
// Function   [ Atpg::evaluateAndSetGateAtpgVal ]
// Commenter  [ KOREAL WWS ]
// Synopsis   [ usage:
// 								The literal meaning of function name.
//							description:
//              	If pGate is the faulty gate, return FaultEvaluation(pGate);
//              	else check the relationships between pGate's evaluated value
//              	and current value.
//
//              	If they are the same, set pGate to be modified,
//              	 return FORWARD,
//              	else if current value is unknown,
//              		set it to the evaluated value and return FORWARD,
//              	else if the evaluated value is different from current value
//              		return CONFLICT,
//              	else (only know current value)
//              		return BackwardImplication(pGate).
//							arguments:
// 								[in] pGate: The gate to do evaluation on.
// 							output:
// 								The implication status after this function call.
//            ]
// Date       [ KOREAL Ver. 1.0 started 2013/08/15 last modifed 2023/01/06 ]
// **************************************************************************
Atpg::IMPLICATION_STATUS Atpg::evaluateAndSetGateAtpgVal(Gate *pGate)
{
	this->gateID_to_valModified_[pGate->gateId_] = 0;

	if (this->gateID_to_lineType_[pGate->gateId_] == HEAD_LINE)
	{
		this->gateID_to_valModified_[pGate->gateId_] = 1;
		return FORWARD;
	}

	if (pGate->gateId_ == this->currentTargetFault_.gateID_)
	{
		return evaluateAndSetFaultyGateAtpgVal(pGate);
	}

	Value evaluatedGoodVal = evaluateGoodVal(*pGate);

	if (pGate->atpgVal_ == evaluatedGoodVal)
	{
		// Good value is equal to the gate output
		if (evaluatedGoodVal != X)
		{
			this->gateID_to_valModified_[pGate->gateId_] = 1;
		}
		return FORWARD;
	}
	else if (pGate->atpgVal_ == X)
	{
		pGate->atpgVal_ = evaluatedGoodVal;
		this->backtrackImplicatedGateIDs_.push_back(pGate->gateId_);
		this->gateID_to_valModified_[pGate->gateId_] = 1;
		pushGateFanoutsToEventStack(pGate->gateId_);
		return FORWARD;
	}
	else if (evaluatedGoodVal != X)
	{ // Good value is different to the gate output
		return CONFLICT;
	}
	// will reach the last return if(atpgVal != X && Val == X)
	return doOneGateBackwardImplication(pGate);
}

// **************************************************************************
// Function   [ Atpg::evaluateAndSetFaultyGateAtpgVal ]
// Commenter  [ KOREAL WWS ]
// Synopsis   [ usage:
// 								The literal meaning of function name.
//
//              Check the relationships between pGate's current value and the
//              evaluated value of pGate.
//
//              If evaluated value is unknown
// 								if pGate has current value,
// 									if only one input has ONE unknown value
// 										set the input to proper value and return BACKWARD
// 									else
// 										push pGate into unjustified_ list
// 							If they are the same
// 								set pGate to be modified, return FORWARD
// 							If the evaluated value is different from current value
// 								return CONFLICT
//
//							arguments:
// 								[in] pGate: The gate to do evaluation on.
// 							output:
// 								The implication status after this function call.
//            ]
// Date       [ KOREAL Ver. 1.0 started 2013/08/15 last modified 2023/01/06 ]
// **************************************************************************
Atpg::IMPLICATION_STATUS Atpg::evaluateAndSetFaultyGateAtpgVal(Gate *pGate)
{
	Value evaluatedFaultyValOfpGate = evaluateFaultyVal(*pGate);
	int faninIndex = 0;
	if (evaluatedFaultyValOfpGate == X)
	{ // The evaluated value is X, means the init faulty objective has not achieved yet.
		if (pGate->atpgVal_ != X)
		{
			int numOfX = 0;

			// Count numOfX, the amount of fanIn whose value is X.
			// set faninIndex to be one of the fanIn whose value is X.
			for (int i = 0; i < pGate->numFI_; ++i)
			{
				Gate *pFaninGate = &this->pCircuit_->circuitGates_[pGate->faninVector_[i]];
				if (pFaninGate->atpgVal_ == X)
				{
					++numOfX;
					faninIndex = i;
				}
			}
			if (numOfX == 1)
			{ // The fanin has X value can be set to implication value

				Value implicatedVal;

				// pImplicatedGate is the pGate's fanIn whose value is X.
				Gate *pImplicatedGate = &(this->pCircuit_->circuitGates_[pGate->faninVector_[faninIndex]]);

				// set ImpVal if pGate is not XOR or XNOR
				if (pGate->atpgVal_ == D)
				{
					implicatedVal = H;
				}
				else if (pGate->atpgVal_ == B)
				{
					implicatedVal = L;
				}
				else
				{
					implicatedVal = pGate->atpgVal_;
				}

				// set ImpVal if pGate is XOR2 or XNOR2
				if (pGate->gateType_ == Gate::XOR2 || pGate->gateType_ == Gate::XNOR2)
				{
					Value temp = (faninIndex == 0) ? this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_ : this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_;
					implicatedVal = cXOR2(implicatedVal, temp);
				}
				// set ImpVal if pGate is XOR3 or XNOR3
				if (pGate->gateType_ == Gate::XOR3 || pGate->gateType_ == Gate::XNOR3)
				{
					Value temp;
					if (faninIndex == 0)
					{
						temp = cXOR2(this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_, this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_);
					}
					else if (faninIndex == 1)
					{
						temp = cXOR2(this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_, this->pCircuit_->circuitGates_[pGate->faninVector_[2]].atpgVal_);
					}
					else
					{
						temp = cXOR2(this->pCircuit_->circuitGates_[pGate->faninVector_[1]].atpgVal_, this->pCircuit_->circuitGates_[pGate->faninVector_[0]].atpgVal_);
					}
					implicatedVal = cXOR2(implicatedVal, temp);
				}

				// if pGate is an inverse function, ImpVal = NOT(ImpVal)
				implicatedVal = cXOR2(implicatedVal, pGate->isInverse());

				// set modify and the final value of pImplicatedGate
				this->gateID_to_valModified_[pGate->gateId_] = 1;
				pImplicatedGate->atpgVal_ = implicatedVal;

				pushGateToEventStack(pGate->faninVector_[faninIndex]);
				pushGateFanoutsToEventStack(pGate->faninVector_[faninIndex]);
				this->backtrackImplicatedGateIDs_.push_back(pImplicatedGate->gateId_);

				return BACKWARD;
			}
			else
			{
				this->unjustifiedGateIDs_.push_back(pGate->gateId_);
			}
		}
	}
	else if (pGate->atpgVal_ == evaluatedFaultyValOfpGate)
	{ // The initial faulty objective has already been achieved
		this->gateID_to_valModified_[pGate->gateId_] = 1;
	}
	else if (pGate->atpgVal_ == X)
	{
		this->gateID_to_valModified_[pGate->gateId_] = 1;
		pGate->atpgVal_ = evaluatedFaultyValOfpGate;
		pushGateFanoutsToEventStack(pGate->gateId_);
		this->backtrackImplicatedGateIDs_.push_back(pGate->gateId_);
	}
	else
	{
		// If the evaluated value is different from current value, return CONFLICT.
		return CONFLICT; 
	}
	return FORWARD;
}

// **************************************************************************
// Function   [ Atpg::staticTestCompressionByReverseFaultSimulation ]
// Commenter  [ CAL WWS ]
// Synopsis   [ usage:
//                Perform reverse fault simulation to do static test 
// 								compression.
//
//              arguments:
// 								[in, out] pPatterProcessor:
// 									The pattern processor contains
// 									the complete test pattern set before STC.
// 									It will then be reassigned to static compressed
// 									test pattern set.
// 								[in, out] originalFaultList
// 									List of faults to be detected. 
// 									Would be modified after this function call.
// 								
//
//            ]
// Date       [ started 2020/07/08    last modified 2023/01/06 ]
// **************************************************************************
void Atpg::staticTestCompressionByReverseFaultSimulation(PatternProcessor *pPatternProcessor, FaultPtrList &originalFaultList)
{
	// reset all the fault to undetected
	for (Fault *pFault : originalFaultList)
	{
		pFault->detection_ = 0;
		if (pFault->faultState_ == Fault::DT)
		{
			pFault->faultState_ = Fault::UD;
		}
	}

	std::vector<Pattern> originalPatternVec = pPatternProcessor->patternVector_;
	pPatternProcessor->patternVector_.clear();
	pPatternProcessor->patternVector_.reserve(originalPatternVec.capacity());

	// Perform reverse fault simulation
	int leftFaultCount = originalFaultList.size();
	for (std::vector<Pattern>::reverse_iterator rit = originalPatternVec.rbegin(); rit != originalPatternVec.rend(); ++rit)
	{
		this->pSimulator_->parallelFaultFaultSimWithOnePattern((*rit), originalFaultList);
		// fault has been detected by the *rit and dropped
		if (leftFaultCount > (int)originalFaultList.size())
		{
			leftFaultCount = (int)originalFaultList.size();
			pPatternProcessor->patternVector_.push_back((*rit));
		}
		else if (leftFaultCount < originalFaultList.size())
		{
			std::cerr << "Bug: staticTestCompressionByReverseFaultSimulation() unexpected behavior\n";
			std::cin.get();
		}
	}
}

// **************************************************************************
// Function   [ Atpg::setUpFirstTimeFrame ]
// Commenter  [ WYH ]
// Synopsis   [ usage: Initial assignment of fault signal, and set the first time
//                     meet HEAD LINE gate.
//                     There are two situations :
//                     1.Faulty gate is FREE LINE
//                      (1)Activate the fault, and set value of pFaultyLineGate
//                         according to fault type.
//                      (2)Do while loop until pFaultyLineGate becomes HEAD LINE
//                      (3)Schedule fanout gates of pFaultyLineGate.
//                     2.Fault is HEAD LINE or BOUND LINE
//                      (1)Activate the fault, and set value of pFaultyLineGate
//                         according to fault type.
//                      (2)Schedule fanout gates of pFaultyLineGate.
//                      (3) Update backwardImplicationLevel to be maximum level of
//                          fanin gates of pFaultyLineGate.
//              in:    Fault& fault
//              out:   int backwardImplicationLevel: The backwardImplicationLevel indicates the backward
//                     imply level return -1 when fault FAULT_UNTESTABLE
//            ]
// Date       [ WYH Ver. 1.0 started 2013/08/17 ]
// **************************************************************************
int Atpg::setUpFirstTimeFrame(Fault &fault)
{ // NE
	int backwardImplicationLevel = 0;
	Gate *pFaultyGate = NULL;
	Gate *pFaultyLineGate = NULL;
	const bool faultIsAtGateOutput = (fault.faultyLine_ == 0);
	Value faultyVal = (fault.faultType_ == Fault::STR) ? L : H;

	pFaultyGate = &this->pCircuit_->circuitGates_[fault.gateID_ - this->pCircuit_->numGate_];

	if (!faultIsAtGateOutput)
	{
		pFaultyLineGate = &this->pCircuit_->circuitGates_[pFaultyGate->faninVector_[fault.faultyLine_ - 1]];
	}
	else
	{
		pFaultyLineGate = pFaultyGate;
	}

	if (this->gateID_to_lineType_[pFaultyLineGate->gateId_] == FREE_LINE)
	{
		if ((faultyVal == H && pFaultyLineGate->atpgVal_ == L) || (faultyVal == L && pFaultyLineGate->atpgVal_ == H))
		{
			return -1;
		}

		pFaultyLineGate->atpgVal_ = faultyVal;
		this->backtrackImplicatedGateIDs_.push_back(pFaultyLineGate->gateId_);
		fanoutFreeBacktrace(pFaultyLineGate);
		Gate *gTemp = pFaultyLineGate;
		Gate *gNext = NULL;
		// propagate until meet the other LINE
		do
		{
			gNext = &this->pCircuit_->circuitGates_[gTemp->fanoutVector_[0]];
			if (!gNext->isUnary() && (gNext->getOutputCtrlValue() == X || gTemp->atpgVal_ != gNext->getInputCtrlValue()))
			{
				break;
			}
			gNext->atpgVal_ = cXOR2(gNext->isInverse(), gTemp->atpgVal_);
			gTemp = gNext;
		} while (this->gateID_to_lineType_[gTemp->gateId_] == FREE_LINE);

		if (this->gateID_to_lineType_[gTemp->gateId_] == HEAD_LINE)
		{
			this->gateID_to_valModified_[gTemp->gateId_] = 1;
			this->backtrackImplicatedGateIDs_.push_back(gTemp->gateId_);
			pushGateFanoutsToEventStack(gTemp->gateId_);
		}
		this->firstTimeFrameHeadLine_ = gTemp;
	}
	else
	{
		if ((faultyVal == H && pFaultyLineGate->atpgVal_ == L) || (faultyVal == L && pFaultyLineGate->atpgVal_ == H))
		{
			return -1;
		}

		pFaultyLineGate->atpgVal_ = faultyVal;
		this->backtrackImplicatedGateIDs_.push_back(pFaultyLineGate->gateId_);
		pushGateFanoutsToEventStack(pFaultyLineGate->gateId_);

		if (this->gateID_to_lineType_[pFaultyLineGate->gateId_] == HEAD_LINE)
		{
			this->gateID_to_valModified_[pFaultyLineGate->gateId_] = 1;
		}
		else if (pFaultyLineGate->gateType_ == Gate::INV || pFaultyLineGate->gateType_ == Gate::BUF || pFaultyLineGate->gateType_ == Gate::PO || pFaultyLineGate->gateType_ == Gate::PPO)
		{
			Gate *pFaninGate = &this->pCircuit_->circuitGates_[pFaultyLineGate->faninVector_[0]];
			this->gateID_to_valModified_[pFaultyLineGate->gateId_] = 1;

			Value Val = faultyVal == H ? H : L;
			Value valueTemp = pFaultyLineGate->isInverse();
			pFaninGate->atpgVal_ = cXOR2(valueTemp, Val);
			this->backtrackImplicatedGateIDs_.push_back(pFaninGate->gateId_);
			pushGateToEventStack(pFaultyLineGate->faninVector_[0]);
			pushGateFanoutsToEventStack(pFaultyLineGate->faninVector_[0]);
			if (backwardImplicationLevel < pFaninGate->numLevel_)
			{
				backwardImplicationLevel = pFaninGate->numLevel_;
			}
		}
		else if ((faultyVal == H && pFaultyLineGate->getOutputCtrlValue() == H) || (faultyVal == L && pFaultyLineGate->getOutputCtrlValue() == L))
		{
			this->gateID_to_valModified_[pFaultyLineGate->gateId_] = 1;
			for (int i = 0; i < pFaultyLineGate->numFI_; ++i)
			{
				Gate *pFaninGate = &this->pCircuit_->circuitGates_[pFaultyLineGate->faninVector_[i]];
				// if the value has not been set, then set it to non-control value
				if (pFaninGate->atpgVal_ == X)
				{
					pFaninGate->atpgVal_ = pFaultyLineGate->getInputNonCtrlValue();
					this->backtrackImplicatedGateIDs_.push_back(pFaninGate->gateId_);
					pushGateToEventStack(pFaultyLineGate->faninVector_[i]);
					pushGateFanoutsToEventStack(pFaultyLineGate->faninVector_[i]);
					// set the backwardImplicationLevel to be maximum of fanin gate's level
					if (backwardImplicationLevel < pFaninGate->numLevel_)
					{
						backwardImplicationLevel = pFaninGate->numLevel_;
					}
				}
			}
		}
		else
		{
			pushGateToEventStack(pFaultyLineGate->gateId_);
			if (backwardImplicationLevel < pFaultyLineGate->numLevel_)
			{
				backwardImplicationLevel = pFaultyLineGate->numLevel_;
			}
		}
	}
	return backwardImplicationLevel;
}

// **************************************************************************
// Function   [ Atpg::checkLevelInfo ]
// Commenter  [ CAL ]
// Synopsis   [ usage:
//                To check if the circuitLvl_ of all the gates does not exceed this->pCircuit_->totalLvl_
//              in:    void
//              out:   void
//            ]
// Date       [ started 2020/07/07    last modified 2020/07/07 ]
// **************************************************************************
void Atpg::checkLevelInfo()
{
	for (int i = 0; i < this->pCircuit_->totalGate_; ++i)
	{
		Gate &gate = this->pCircuit_->circuitGates_[i];
		if (gate.numLevel_ >= this->pCircuit_->totalLvl_)
		{
			std::cerr << "checkLevelInfo found that at least one gate.numLevel_ is greater than this->pCircuit_->totalLvl_\n";
			std::cin.get();
		}
	}
}

// **************************************************************************
// Function   [ Atpg::getValStr ]
// Commenter  [ CAL ]
// Synopsis   [ usage: return string type of Value
//              in:    Value
//              out:   string of Value
//            ]
// Date       [ started 2020/07/04    last modified 2020/07/04 ]
// **************************************************************************
std::string Atpg::getValStr(Value val)
{
	std::string valStr;
	switch (val)
	{
		case H:
			valStr = "H";
			break;
		case L:
			valStr = "L";
			break;
		case D:
			valStr = "D";
			break;
		case B:
			valStr = "B";
			break;
		case X:
			valStr = "X";
			break;
		default:
			valStr = "Error";
			break;
	}
	return valStr;
}

// TODO comment
// created by Wang, Wei-Shen, currently not used
void Atpg::calSCOAP()
{
	// cc0, cc1 and co default is 0, check if is changed before
	for (int gateID = 0; gateID < this->pCircuit_->totalGate_; ++gateID)
	{
		Gate &gate = this->pCircuit_->circuitGates_[gateID];
		if (gate.cc0_ != 0)
		{
			std::cerr << "Bug: cc0_ is not -1\n";
			std::cin.get();
		}
		if (gate.cc1_ != 0)
		{
			std::cerr << "Bug: cc1_ is not -1\n";
			std::cin.get();
		}
		if (gate.co_ != 0)
		{
			std::cerr << "Bug: co_ is not -1\n";
			std::cin.get();
		}
	}

	// array for xor2, xor3, xnor2, xnor3
	// xor2 xnor2 : {00,01,10,11}
	// xor3 xnor3 : {000, 001, 010, 011, 100, 101, 110, 111}
	int xorcc[8] = {0};
	Gate gateInputs[3];

	// calculate cc0 and cc1 starting from PI and PPI
	for (int gateID = 0; gateID < this->pCircuit_->totalGate_; ++gateID)
	{
		Gate &gate = this->pCircuit_->circuitGates_[gateID];
		switch (gate.gateType_)
		{
			case Gate::PPI:
			case Gate::PI:
				gate.cc0_ = 1;
				gate.cc1_ = 1;
				break;
			case Gate::PO:
			case Gate::PPO:
			case Gate::BUF:
				gate.cc0_ = this->pCircuit_->circuitGates_[gate.faninVector_[0]].cc0_;
				gate.cc1_ = this->pCircuit_->circuitGates_[gate.faninVector_[0]].cc1_;
				break;
			case Gate::INV:
				gate.cc0_ = this->pCircuit_->circuitGates_[gate.faninVector_[0]].cc1_ + 1;
				gate.cc1_ = this->pCircuit_->circuitGates_[gate.faninVector_[0]].cc0_ + 1;
				break;
			case Gate::AND2:
			case Gate::AND3:
			case Gate::AND4:
				for (int j = 0; j < gate.numFI_; ++j)
				{
					Gate &gateInput = this->pCircuit_->circuitGates_[gate.faninVector_[j]];
					if (j == 0 || (gateInput.cc0_ < gate.cc0_))
					{
						gate.cc0_ = gateInput.cc0_;
					}
					gate.cc1_ += gateInput.cc1_;
				}
				++gate.cc1_;
				++gate.cc0_;
				break;
			case Gate::NAND2:
			case Gate::NAND3:
			case Gate::NAND4:
				for (int j = 0; j < gate.numFI_; ++j)
				{
					Gate &gateInput = this->pCircuit_->circuitGates_[gate.faninVector_[j]];
					if (j == 0 || (gateInput.cc0_ < gate.cc1_))
					{
						gate.cc1_ = gateInput.cc0_;
					}
					gate.cc0_ += gateInput.cc1_;
				}
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::OR2:
			case Gate::OR3:
			case Gate::OR4:
				for (int j = 0; j < gate.numFI_; ++j)
				{
					Gate &gateInput = this->pCircuit_->circuitGates_[gate.faninVector_[j]];
					if (j == 0 || (gateInput.cc1_ < gate.cc1_))
					{
						gate.cc1_ = gateInput.cc1_;
					}
					gate.cc0_ += gateInput.cc0_;
				}
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::NOR2:
			case Gate::NOR3:
			case Gate::NOR4:
				for (int j = 0; j < gate.numFI_; ++j)
				{
					Gate &gateInput = this->pCircuit_->circuitGates_[gate.faninVector_[j]];
					if (j == 0 || (gateInput.cc1_ < gate.cc0_))
					{
						gate.cc0_ = gateInput.cc1_;
					}
					gate.cc1_ += gateInput.cc0_;
				}
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::XOR2:
				gateInputs[0] = this->pCircuit_->circuitGates_[gate.faninVector_[0]];
				gateInputs[1] = this->pCircuit_->circuitGates_[gate.faninVector_[1]];
				xorcc[0] = gateInputs[0].cc0_ + gateInputs[1].cc0_;
				xorcc[1] = gateInputs[0].cc0_ + gateInputs[1].cc1_;
				xorcc[2] = gateInputs[0].cc1_ + gateInputs[1].cc0_;
				xorcc[3] = gateInputs[0].cc1_ + gateInputs[1].cc1_;
				gate.cc0_ = std::min(xorcc[0], xorcc[3]);
				gate.cc1_ = std::min(xorcc[1], xorcc[2]);
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::XOR3:
				gateInputs[0] = this->pCircuit_->circuitGates_[gate.faninVector_[0]];
				gateInputs[1] = this->pCircuit_->circuitGates_[gate.faninVector_[1]];
				gateInputs[2] = this->pCircuit_->circuitGates_[gate.faninVector_[2]];
				xorcc[0] = gateInputs[0].cc0_ + gateInputs[1].cc0_ + gateInputs[2].cc0_;
				xorcc[1] = gateInputs[0].cc0_ + gateInputs[1].cc0_ + gateInputs[2].cc1_;
				xorcc[2] = gateInputs[0].cc0_ + gateInputs[1].cc1_ + gateInputs[2].cc0_;
				xorcc[3] = gateInputs[0].cc0_ + gateInputs[1].cc1_ + gateInputs[2].cc1_;
				xorcc[4] = gateInputs[0].cc1_ + gateInputs[1].cc0_ + gateInputs[2].cc0_;
				xorcc[5] = gateInputs[0].cc1_ + gateInputs[1].cc0_ + gateInputs[2].cc1_;
				xorcc[6] = gateInputs[0].cc1_ + gateInputs[1].cc1_ + gateInputs[2].cc0_;
				xorcc[7] = gateInputs[0].cc1_ + gateInputs[1].cc1_ + gateInputs[2].cc1_;
				gate.cc0_ = std::min(xorcc[0], xorcc[7]);
				for (int j = 1; j < 7; ++j)
				{
					if (j == 1 || xorcc[j] < gate.cc1_)
					{
						gate.cc1_ = xorcc[j];
					}
				}
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::XNOR2:
				gateInputs[0] = this->pCircuit_->circuitGates_[gate.faninVector_[0]];
				gateInputs[1] = this->pCircuit_->circuitGates_[gate.faninVector_[1]];
				xorcc[0] = gateInputs[0].cc0_ + gateInputs[1].cc0_;
				xorcc[1] = gateInputs[0].cc0_ + gateInputs[1].cc1_;
				xorcc[2] = gateInputs[0].cc1_ + gateInputs[1].cc0_;
				xorcc[3] = gateInputs[0].cc1_ + gateInputs[1].cc1_;
				gate.cc0_ = std::min(xorcc[1], xorcc[2]);
				gate.cc1_ = std::min(xorcc[0], xorcc[3]);
				++gate.cc0_;
				++gate.cc1_;
				break;
			case Gate::XNOR3:
				gateInputs[0] = this->pCircuit_->circuitGates_[gate.faninVector_[0]];
				gateInputs[1] = this->pCircuit_->circuitGates_[gate.faninVector_[1]];
				gateInputs[2] = this->pCircuit_->circuitGates_[gate.faninVector_[2]];
				xorcc[0] = gateInputs[0].cc0_ + gateInputs[1].cc0_ + gateInputs[2].cc0_;
				xorcc[1] = gateInputs[0].cc0_ + gateInputs[1].cc0_ + gateInputs[2].cc1_;
				xorcc[2] = gateInputs[0].cc0_ + gateInputs[1].cc1_ + gateInputs[2].cc0_;
				xorcc[3] = gateInputs[0].cc0_ + gateInputs[1].cc1_ + gateInputs[2].cc1_;
				xorcc[4] = gateInputs[0].cc1_ + gateInputs[1].cc0_ + gateInputs[2].cc0_;
				xorcc[5] = gateInputs[0].cc1_ + gateInputs[1].cc0_ + gateInputs[2].cc1_;
				xorcc[6] = gateInputs[0].cc1_ + gateInputs[1].cc1_ + gateInputs[2].cc0_;
				xorcc[7] = gateInputs[0].cc1_ + gateInputs[1].cc1_ + gateInputs[2].cc1_;
				gate.cc1_ = std::min(xorcc[0], xorcc[7]);
				for (int j = 1; j < 7; ++j)
				{
					if (j == 1 || xorcc[j] < gate.cc1_)
					{
						gate.cc0_ = xorcc[j];
					}
				}
				++gate.cc0_;
				++gate.cc1_;
				break;
			default:
				std::cerr << "Bug: reach switch case default while calculating cc0_, cc1_";
				std::cin.get();
				break;
		}
	}

	// calculate co_ starting from PO and PP
	for (int gateID = 0; gateID < this->pCircuit_->totalGate_; ++gateID)
	{
		Gate &gate = this->pCircuit_->circuitGates_[gateID];
		switch (gate.gateType_)
		{
			case Gate::PO:
			case Gate::PPO:
				gate.co_ = 0;
				break;
			case Gate::PPI:
			case Gate::PI:
			case Gate::BUF:
				for (int j = 0; j < gate.numFO_; ++j)
				{
					if (j == 0 || this->pCircuit_->circuitGates_[gate.fanoutVector_[j]].co_ < gate.co_)
					{
						gate.co_ = this->pCircuit_->circuitGates_[gate.fanoutVector_[j]].co_;
					}
				}
				break;
			case Gate::INV:
				gate.co_ = this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].co_ + 1;
				break;
			case Gate::AND2:
			case Gate::AND3:
			case Gate::AND4:
			case Gate::NAND2:
			case Gate::NAND3:
			case Gate::NAND4:
				gate.co_ = this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].co_ + 1;
				for (int j = 0; j < this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].numFI_; ++j)
				{
					if (this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j] != gateID)
					{
						Gate &gateSibling = this->pCircuit_->circuitGates_[this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j]];
						gate.co_ += gateSibling.cc1_;
					}
				}
				break;
			case Gate::OR2:
			case Gate::OR3:
			case Gate::OR4:
			case Gate::NOR2:
			case Gate::NOR3:
			case Gate::NOR4:
				gate.co_ = this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].co_ + 1;
				for (int j = 0; j < this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].numFI_; ++j)
				{
					if (this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j] != gateID)
					{
						Gate &gateSibling = this->pCircuit_->circuitGates_[this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j]];
						gate.co_ += gateSibling.cc0_;
					}
				}
				break;
			case Gate::XOR2:
			case Gate::XNOR2:
			case Gate::XOR3:
			case Gate::XNOR3:
				gate.co_ = this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].co_ + 1;
				for (int j = 0; j < this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].numFI_; ++j)
				{
					Gate &gateSibling = this->pCircuit_->circuitGates_[this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j]];
					if (this->pCircuit_->circuitGates_[gate.fanoutVector_[0]].faninVector_[j] != gateID)
					{
						gate.co_ += std::min(gateSibling.cc0_, gateSibling.cc1_);
					}
				}
				break;
			default:
				std::cerr << "Bug: reach switch case default while calculating co_";
				std::cin.get();
				break;
		}
	}

	return;
}

// **************************************************************************
// Function   [ Atpg::testClearFaultEffect ]
// Commenter  [ CAL ]
// Synopsis   [ usage:
//                Test clearAllFaultEffectByEvaluation for all faults
//              in:    void
//              out:   void
//            ]
// Date       [ started 2020/07/04    last modified 2020/07/04 ]
// **************************************************************************
void Atpg::testClearFaultEffect(FaultPtrList &faultListToTest)
{
	for (Fault *pFault : faultListToTest)
	{
		generateSinglePatternOnTargetFault(*pFault, false);
		clearAllFaultEffectByEvaluation();

		for (int i = 0; i < this->pCircuit_->totalGate_; ++i)
		{
			Gate &gate = this->pCircuit_->circuitGates_[i];
			if ((gate.atpgVal_ == D) || (gate.atpgVal_ == B))
			{
				std::cerr << "testClearFaultEffect found bug" << std::endl;
				std::cin.get();
			}
		}
	}
}

// **************************************************************************
// Function   [ Atpg::resetIsInEventStack ]
// Commenter  [ CAL ]
// Synopsis   [ usage:
//                Set all element in this->isInEventStack_ to false
//              in:    void
//              out:   void
//            ]
// Date       [ started 2020/07/07    last modified 2020/07/07 ]
// **************************************************************************
void Atpg::resetIsInEventStack()
{
	std::fill(this->isInEventStack_.begin(), this->isInEventStack_.end(), 0);
}

// **************************************************************************
// Function   [ Atpg::XFill ]
// Commenter  [ HKY CYW ]
// Synopsis   [ usage: do X-Fill on generated pattern
//              in:    Pattern list
//              out:   void //TODO
//            ]
// Date       [ HKY Ver. 1.0 started 2014/09/01 ]
// **************************************************************************
void Atpg::XFill(PatternProcessor *pPatternProcessor)
{
	for (int i = 0; i < (int)pPatternProcessor->patternVector_.size(); ++i)
	{
		randomFill(pPatternProcessor->patternVector_[i]);
		this->pSimulator_->assignPatternToCircuitInputs(pPatternProcessor->patternVector_.at(i));
		this->pSimulator_->goodSim();
		writeGoodSimValToPatternPO(pPatternProcessor->patternVector_.at(i));
	}
}