#define yy_create_buffer sdf_file_create_buffer
#define yy_delete_buffer sdf_file_delete_buffer
#define yy_scan_buffer sdf_file_scan_buffer
#define yy_scan_string sdf_file_scan_string
#define yy_scan_bytes sdf_file_scan_bytes
#define yy_flex_debug sdf_file_flex_debug
#define yy_init_buffer sdf_file_init_buffer
#define yy_flush_buffer sdf_file_flush_buffer
#define yy_load_buffer_state sdf_file_load_buffer_state
#define yy_switch_to_buffer sdf_file_switch_to_buffer
#define yyin sdf_filein
#define yyleng sdf_fileleng
#define yylex sdf_filelex
#define yyout sdf_fileout
#define yyrestart sdf_filerestart
#define yytext sdf_filetext

#line 19 "lib/opt/lex_n_yacc/sdf_file.yy.cpp"
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>
#include <errno.h>

/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus

#include <stdlib.h>
#ifndef _WIN32
#include <unistd.h>
#endif

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif /* __STDC__ */
#endif /* ! __cplusplus */

#ifdef __TURBOC__
#pragma warn - rch
#pragma warn - use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n)                                  \
	do                                               \
	{                                                \
		/* Undo effects of setting up yytext. */       \
		*yy_cp = yy_hold_char;                         \
		YY_RESTORE_YY_MORE_OFFSET                      \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ;  \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
	} while (0)

#define unput(c) yyunput(c, yytext_ptr)

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;

struct yy_buffer_state
{
	FILE *yy_input_file;

	char *yy_ch_buf;	/* input buffer */
	char *yy_buf_pos; /* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars; /* number of characters read into yy_ch_buf */

int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *)0;
static int yy_init = 1;	 /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO((FILE * input_file));

void yy_switch_to_buffer YY_PROTO((YY_BUFFER_STATE new_buffer));
void yy_load_buffer_state YY_PROTO((void));
YY_BUFFER_STATE yy_create_buffer YY_PROTO((FILE * file, int size));
void yy_delete_buffer YY_PROTO((YY_BUFFER_STATE b));
void yy_init_buffer YY_PROTO((YY_BUFFER_STATE b, FILE *file));
void yy_flush_buffer YY_PROTO((YY_BUFFER_STATE b));
#define YY_FLUSH_BUFFER yy_flush_buffer(yy_current_buffer)

YY_BUFFER_STATE yy_scan_buffer YY_PROTO((char *base, yy_size_t size));
YY_BUFFER_STATE yy_scan_string YY_PROTO((yyconst char *yy_str));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO((yyconst char *bytes, int len));

static void *yy_flex_alloc YY_PROTO((yy_size_t));
static void *yy_flex_realloc YY_PROTO((void *, yy_size_t));
static void yy_flex_free YY_PROTO((void *));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                     \
	{                                                            \
		if (!yy_current_buffer)                                    \
			yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \
		yy_current_buffer->yy_is_interactive = is_interactive;     \
	}

#define yy_set_bol(at_bol)                                     \
	{                                                            \
		if (!yy_current_buffer)                                    \
			yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \
		yy_current_buffer->yy_at_bol = at_bol;                     \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

#define yywrap() 1
#define YY_SKIP_YYWRAP
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *)0, *yyout = (FILE *)0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO((void));
static yy_state_type yy_try_NUL_trans YY_PROTO((yy_state_type current_state));
static int yy_get_next_buffer YY_PROTO((void));
static void yy_fatal_error YY_PROTO((yyconst char msg[]));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION      \
	yytext_ptr = yy_bp;            \
	yyleng = (int)(yy_cp - yy_bp); \
	yy_hold_char = *yy_cp;         \
	*yy_cp = '\0';                 \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 105
#define YY_END_OF_BUFFER 106
static yyconst short int yy_accept[398] =
		{0,
		 0, 0, 0, 0, 106, 104, 103, 102, 87, 104,
		 82, 92, 104, 95, 96, 94, 89, 101, 90, 85,
		 86, 65, 65, 65, 100, 83, 104, 84, 99, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		 64, 64, 64, 93, 64, 64, 97, 91, 98, 88,
		 5, 4, 5, 71, 0, 60, 0, 72, 0, 0,
		 0, 65, 67, 2, 1, 66, 63, 0, 77, 74,
		 70, 75, 76, 0, 64, 64, 64, 0, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,

		 64, 64, 64, 64, 64, 64, 64, 81, 64, 64,
		 73, 78, 80, 79, 3, 69, 62, 0, 1, 66,
		 0, 0, 0, 68, 61, 64, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 51, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 0, 67, 0,
		 0, 66, 61, 0, 64, 64, 64, 18, 30, 9,
		 64, 64, 64, 64, 52, 64, 64, 38, 64, 64,
		 64, 64, 47, 64, 64, 64, 34, 64, 64, 64,

		 64, 64, 64, 64, 64, 64, 43, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 0, 66,
		 64, 64, 32, 64, 64, 21, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		 64, 64, 64, 64, 64, 31, 64, 37, 64, 56,
		 64, 64, 64, 64, 64, 64, 64, 44, 64, 64,
		 64, 64, 64, 64, 64, 64, 8, 36, 64, 64,
		 64, 64, 64, 28, 64, 64, 64, 45, 64, 64,
		 64, 42, 64, 29, 64, 64, 64, 64, 64, 64,
		 10, 64, 64, 64, 64, 64, 64, 54, 64, 64,

		 64, 64, 13, 64, 64, 64, 64, 64, 64, 64,
		 64, 15, 11, 64, 41, 64, 64, 64, 64, 64,
		 64, 64, 12, 14, 64, 59, 58, 26, 19, 33,
		 64, 64, 64, 64, 20, 64, 46, 64, 64, 64,
		 40, 64, 64, 64, 64, 64, 64, 64, 57, 6,
		 55, 48, 27, 64, 64, 24, 64, 64, 39, 64,
		 64, 17, 64, 23, 64, 64, 64, 64, 7, 64,
		 64, 64, 64, 64, 64, 64, 64, 16, 22, 35,
		 64, 64, 64, 64, 64, 64, 64, 64, 49, 64,
		 64, 53, 64, 64, 25, 50, 0

};

static yyconst int yy_ec[256] =
		{0,
		 1, 1, 1, 1, 1, 1, 1, 1, 2, 3,
		 2, 2, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 2, 4, 5, 6, 6, 7, 8, 9, 10,
		 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
		 20, 20, 20, 20, 20, 20, 20, 21, 6, 22,
		 23, 24, 25, 1, 26, 27, 28, 29, 30, 31,
		 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
		 35, 42, 43, 44, 45, 46, 47, 48, 49, 35,
		 6, 50, 6, 51, 35, 6, 35, 52, 35, 53,

		 54, 35, 55, 35, 35, 35, 35, 35, 35, 56,
		 57, 58, 35, 35, 59, 35, 35, 35, 35, 35,
		 35, 60, 61, 62, 63, 64, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1};

static yyconst int yy_meta[65] =
		{0,
		 1, 1, 2, 3, 3, 3, 3, 3, 3, 3,
		 3, 3, 3, 3, 3, 4, 4, 5, 5, 5,
		 3, 3, 3, 3, 3, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 5,
		 3, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 3, 3, 3, 3};

static yyconst short int yy_base[406] =
		{0,
		 0, 0, 62, 63, 197, 1735, 1735, 1735, 160, 62,
		 1735, 171, 41, 1735, 1735, 1735, 53, 1735, 60, 63,
		 72, 72, 78, 83, 1735, 63, 131, 81, 1735, 91,
		 93, 97, 100, 103, 105, 119, 123, 140, 112, 148,
		 158, 151, 170, 88, 155, 178, 1735, 86, 1735, 138,
		 1735, 1735, 127, 88, 65, 1735, 97, 1735, 105, 142,
		 192, 197, 203, 1735, 0, 206, 1735, 79, 1735, 1735,
		 72, 1735, 1735, 0, 190, 202, 213, 0, 221, 225,
		 215, 230, 227, 250, 262, 232, 267, 272, 269, 275,
		 277, 281, 288, 292, 312, 299, 317, 319, 327, 329,

		 335, 337, 342, 344, 354, 349, 372, 1735, 365, 380,
		 1735, 1735, 1735, 1735, 1735, 1735, 1735, 387, 0, 391,
		 399, 184, 232, 1735, 407, 409, 412, 415, 418, 421,
		 426, 435, 447, 424, 450, 461, 453, 463, 431, 466,
		 473, 479, 488, 482, 485, 503, 490, 505, 509, 514,
		 511, 517, 529, 531, 541, 546, 554, 549, 556, 558,
		 573, 567, 578, 584, 595, 599, 602, 606, 611, 622,
		 628, 639, 604, 0, 627, 616, 634, 644, 651, 653,
		 655, 657, 659, 662, 666, 669, 676, 679, 694, 697,
		 704, 711, 714, 716, 721, 718, 723, 735, 740, 743,

		 753, 758, 760, 762, 770, 764, 779, 781, 785, 802,
		 805, 807, 809, 811, 817, 823, 825, 833, 844, 850,
		 837, 855, 849, 860, 863, 872, 868, 875, 877, 881,
		 879, 899, 885, 904, 917, 922, 924, 926, 928, 930,
		 936, 939, 943, 949, 966, 968, 971, 974, 979, 981,
		 984, 986, 993, 995, 1006, 1016, 1011, 1022, 1024, 1033,
		 1036, 1041, 1043, 1046, 1048, 1052, 1054, 1059, 1078, 1083,
		 1089, 1094, 1091, 1096, 1098, 1108, 1118, 1110, 1120, 1126,
		 1133, 1135, 1137, 1140, 1145, 1149, 1155, 1165, 1176, 1180,
		 1161, 1184, 1187, 1190, 1196, 1202, 1205, 1208, 1211, 1227,

		 1222, 1231, 1237, 1246, 1249, 1252, 1254, 1259, 1262, 1267,
		 1274, 1278, 1281, 1284, 1290, 1302, 1304, 1299, 1306, 1309,
		 1322, 1327, 1313, 1331, 1341, 1344, 1348, 1351, 1353, 1357,
		 1359, 1366, 1369, 1371, 1376, 1383, 1388, 1395, 1397, 1401,
		 1407, 1412, 1414, 1419, 1425, 1437, 1442, 1432, 1439, 1444,
		 1449, 1457, 1460, 1463, 1467, 1474, 1469, 1479, 1481, 1484,
		 1486, 1488, 1504, 1506, 1523, 1526, 1528, 1530, 1532, 1543,
		 1545, 1547, 1550, 1554, 1568, 1570, 1573, 1575, 1582, 1585,
		 1589, 1598, 1605, 1613, 1592, 1617, 1624, 1600, 1621, 1629,
		 1637, 1640, 1644, 1648, 1653, 1656, 1735, 1706, 1712, 1715,

		 1721, 71, 1725, 1726, 1730};

static yyconst short int yy_def[406] =
		{0,
		 397, 1, 398, 398, 397, 397, 397, 397, 397, 399,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 397, 400, 400, 397, 397, 397, 397,
		 397, 397, 397, 397, 399, 397, 399, 397, 397, 397,
		 397, 397, 397, 397, 401, 397, 397, 397, 397, 397,
		 397, 397, 397, 402, 400, 400, 400, 403, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,

		 400, 400, 400, 400, 400, 400, 400, 397, 400, 400,
		 397, 397, 397, 397, 397, 397, 397, 397, 401, 397,
		 397, 397, 397, 397, 404, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 397, 397, 397,
		 397, 397, 404, 405, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,

		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 397, 397,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,

		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
		 400, 400, 400, 400, 400, 400, 0, 397, 397, 397,

		 397, 397, 397, 397, 397};

static yyconst short int yy_nxt[1800] =
		{0,
		 6, 7, 8, 9, 10, 6, 11, 12, 13, 14,
		 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
		 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
		 31, 31, 35, 36, 31, 31, 31, 31, 37, 31,
		 38, 39, 40, 41, 31, 42, 43, 31, 31, 6,
		 44, 31, 31, 31, 31, 45, 31, 46, 31, 31,
		 47, 48, 49, 50, 52, 52, 56, 59, 61, 56,
		 62, 62, 62, 53, 53, 61, 125, 62, 62, 62,
		 63, 63, 63, 64, 69, 70, 68, 66, 65, 62,
		 62, 62, 60, 66, 124, 62, 62, 62, 66, 397,

		 62, 62, 62, 72, 73, 122, 74, 74, 74, 74,
		 116, 57, 74, 74, 57, 74, 74, 76, 74, 74,
		 74, 74, 117, 117, 79, 82, 80, 74, 74, 83,
		 123, 67, 77, 84, 74, 74, 81, 67, 74, 74,
		 78, 95, 78, 115, 86, 112, 78, 111, 89, 78,
		 85, 108, 78, 71, 78, 74, 74, 87, 88, 117,
		 117, 78, 90, 74, 74, 91, 74, 74, 78, 92,
		 74, 74, 78, 74, 74, 96, 97, 98, 58, 93,
		 104, 94, 54, 99, 100, 74, 74, 102, 113, 78,
		 105, 103, 101, 74, 74, 106, 397, 78, 397, 114,

		 78, 117, 117, 107, 78, 74, 74, 78, 109, 63,
		 63, 63, 66, 397, 62, 62, 62, 74, 74, 78,
		 63, 63, 63, 120, 120, 120, 397, 78, 74, 74,
		 74, 74, 118, 397, 110, 121, 74, 74, 397, 78,
		 74, 74, 74, 74, 126, 74, 74, 74, 74, 117,
		 117, 78, 397, 130, 127, 397, 118, 397, 397, 121,
		 128, 129, 78, 132, 78, 74, 74, 133, 139, 134,
		 78, 397, 135, 131, 78, 397, 78, 74, 74, 78,
		 136, 78, 74, 74, 74, 74, 397, 74, 74, 138,
		 74, 74, 74, 74, 140, 137, 74, 74, 397, 78,

		 397, 397, 145, 74, 74, 397, 144, 74, 74, 141,
		 142, 78, 143, 397, 74, 74, 78, 397, 78, 397,
		 146, 78, 147, 397, 78, 397, 78, 74, 74, 148,
		 78, 149, 74, 74, 74, 74, 397, 78, 153, 150,
		 397, 78, 74, 74, 74, 74, 397, 154, 78, 151,
		 74, 74, 74, 74, 157, 152, 156, 74, 74, 74,
		 74, 78, 155, 397, 74, 74, 78, 397, 78, 74,
		 74, 397, 158, 397, 159, 397, 78, 397, 78, 160,
		 74, 74, 161, 397, 78, 162, 78, 74, 74, 397,
		 163, 78, 397, 78, 164, 74, 74, 397, 78, 168,

		 165, 168, 397, 78, 169, 169, 169, 397, 120, 120,
		 120, 171, 397, 171, 78, 397, 172, 172, 172, 166,
		 170, 78, 74, 74, 74, 74, 397, 74, 74, 78,
		 74, 74, 397, 74, 74, 397, 74, 74, 167, 74,
		 74, 74, 74, 397, 170, 176, 74, 74, 175, 179,
		 74, 74, 397, 177, 178, 180, 174, 183, 78, 188,
		 181, 78, 74, 74, 78, 74, 74, 78, 74, 74,
		 78, 397, 182, 78, 397, 78, 74, 74, 74, 74,
		 78, 74, 74, 184, 78, 397, 186, 397, 74, 74,
		 397, 185, 187, 397, 74, 74, 78, 74, 74, 78,

		 74, 74, 78, 74, 74, 74, 74, 189, 191, 397,
		 78, 193, 78, 192, 397, 78, 190, 194, 74, 74,
		 74, 74, 78, 196, 74, 74, 74, 74, 78, 74,
		 74, 78, 74, 74, 78, 195, 198, 78, 397, 78,
		 199, 397, 203, 397, 74, 74, 74, 74, 197, 397,
		 202, 397, 78, 200, 78, 201, 74, 74, 78, 397,
		 78, 74, 74, 78, 74, 74, 78, 204, 397, 74,
		 74, 74, 74, 74, 74, 397, 205, 397, 78, 397,
		 78, 208, 74, 74, 397, 206, 397, 210, 74, 74,
		 78, 211, 207, 74, 74, 78, 209, 397, 78, 74,

		 74, 212, 397, 78, 397, 78, 397, 78, 397, 213,
		 74, 74, 397, 215, 74, 74, 78, 74, 74, 74,
		 74, 214, 78, 169, 169, 169, 397, 78, 169, 169,
		 169, 74, 74, 78, 219, 397, 219, 397, 216, 220,
		 220, 220, 74, 74, 78, 172, 172, 172, 78, 74,
		 74, 78, 217, 174, 397, 218, 172, 172, 172, 74,
		 74, 222, 223, 221, 397, 78, 74, 74, 74, 74,
		 74, 74, 74, 74, 74, 74, 78, 74, 74, 397,
		 225, 74, 74, 78, 74, 74, 397, 224, 397, 229,
		 228, 74, 74, 78, 74, 74, 397, 230, 227, 397,

		 78, 397, 78, 226, 78, 397, 78, 397, 78, 74,
		 74, 78, 74, 74, 397, 78, 231, 397, 78, 74,
		 74, 397, 233, 232, 397, 78, 74, 74, 78, 74,
		 74, 74, 74, 74, 74, 397, 74, 74, 74, 74,
		 397, 236, 397, 78, 397, 234, 78, 397, 237, 397,
		 74, 74, 397, 78, 235, 74, 74, 239, 74, 74,
		 78, 238, 397, 78, 240, 78, 397, 78, 74, 74,
		 78, 397, 78, 74, 74, 74, 74, 74, 74, 74,
		 74, 241, 243, 397, 78, 74, 74, 397, 242, 78,
		 246, 397, 78, 245, 74, 74, 74, 74, 397, 247,

		 74, 74, 78, 244, 248, 397, 249, 78, 397, 78,
		 397, 78, 397, 78, 251, 397, 250, 74, 74, 78,
		 74, 74, 74, 74, 74, 74, 74, 74, 78, 397,
		 78, 397, 74, 74, 78, 397, 256, 397, 74, 74,
		 74, 74, 255, 253, 252, 397, 254, 257, 74, 74,
		 397, 78, 74, 74, 78, 258, 78, 397, 78, 397,
		 78, 220, 220, 220, 74, 74, 78, 220, 220, 220,
		 74, 74, 78, 397, 78, 74, 74, 259, 74, 74,
		 262, 261, 78, 74, 74, 260, 78, 74, 74, 397,
		 74, 74, 74, 74, 74, 74, 74, 74, 78, 264,

		 74, 74, 265, 397, 78, 397, 268, 397, 263, 78,
		 269, 266, 78, 267, 74, 74, 397, 78, 397, 74,
		 74, 78, 270, 272, 78, 397, 78, 397, 78, 397,
		 78, 273, 74, 74, 78, 397, 271, 74, 74, 74,
		 74, 74, 74, 74, 74, 74, 74, 397, 78, 274,
		 397, 74, 74, 78, 74, 74, 278, 397, 74, 74,
		 275, 280, 397, 276, 74, 74, 78, 397, 281, 397,
		 277, 78, 279, 78, 283, 78, 397, 78, 397, 78,
		 282, 74, 74, 74, 74, 78, 74, 74, 78, 74,
		 74, 397, 78, 397, 74, 74, 74, 74, 78, 74,

		 74, 74, 74, 397, 284, 397, 286, 397, 74, 74,
		 74, 74, 285, 289, 397, 78, 397, 78, 287, 397,
		 78, 74, 74, 78, 290, 288, 74, 74, 78, 397,
		 78, 74, 74, 78, 397, 78, 291, 74, 74, 74,
		 74, 397, 78, 397, 78, 292, 397, 293, 74, 74,
		 294, 74, 74, 397, 397, 78, 74, 74, 74, 74,
		 78, 74, 74, 74, 74, 78, 397, 74, 74, 74,
		 74, 78, 397, 78, 74, 74, 397, 298, 295, 297,
		 397, 301, 78, 299, 397, 78, 397, 296, 300, 397,
		 78, 397, 78, 74, 74, 78, 302, 78, 74, 74,

		 397, 78, 397, 78, 74, 74, 74, 74, 78, 74,
		 74, 74, 74, 74, 74, 397, 304, 397, 305, 303,
		 397, 306, 397, 74, 74, 74, 74, 78, 397, 308,
		 307, 397, 78, 74, 74, 74, 74, 311, 78, 397,
		 78, 74, 74, 78, 397, 78, 309, 78, 74, 74,
		 74, 74, 74, 74, 310, 74, 74, 78, 397, 78,
		 74, 74, 312, 313, 74, 74, 397, 78, 397, 78,
		 74, 74, 397, 315, 314, 78, 74, 74, 397, 397,
		 74, 74, 78, 397, 78, 397, 78, 316, 317, 78,
		 319, 74, 74, 318, 78, 74, 74, 397, 78, 74,

		 74, 320, 74, 74, 78, 74, 74, 321, 397, 322,
		 78, 74, 74, 397, 78, 397, 324, 74, 74, 397,
		 74, 74, 323, 74, 74, 78, 74, 74, 397, 78,
		 397, 325, 397, 78, 328, 397, 78, 74, 74, 78,
		 329, 397, 74, 74, 397, 78, 74, 74, 397, 326,
		 397, 78, 74, 74, 78, 327, 330, 78, 331, 397,
		 78, 74, 74, 397, 74, 74, 397, 74, 74, 74,
		 74, 78, 332, 397, 74, 74, 78, 74, 74, 397,
		 78, 335, 74, 74, 397, 333, 78, 334, 337, 74,
		 74, 397, 336, 74, 74, 78, 74, 74, 78, 74,

		 74, 78, 397, 78, 338, 74, 74, 397, 78, 339,
		 397, 78, 397, 340, 74, 74, 78, 74, 74, 74,
		 74, 74, 74, 78, 74, 74, 397, 78, 74, 74,
		 78, 397, 341, 78, 397, 342, 397, 74, 74, 78,
		 343, 344, 74, 74, 397, 346, 74, 74, 78, 345,
		 397, 78, 397, 78, 347, 78, 74, 74, 78, 74,
		 74, 397, 78, 74, 74, 348, 74, 74, 74, 74,
		 397, 78, 74, 74, 74, 74, 78, 397, 349, 397,
		 78, 74, 74, 397, 74, 74, 74, 74, 350, 397,
		 78, 74, 74, 78, 397, 351, 397, 78, 74, 74,

		 78, 397, 78, 74, 74, 397, 78, 352, 78, 397,
		 74, 74, 74, 74, 353, 78, 74, 74, 78, 397,
		 78, 354, 74, 74, 397, 78, 356, 74, 74, 74,
		 74, 397, 78, 397, 74, 74, 397, 78, 355, 357,
		 74, 74, 359, 397, 78, 397, 78, 74, 74, 397,
		 78, 358, 74, 74, 74, 74, 78, 74, 74, 74,
		 74, 78, 360, 78, 74, 74, 362, 397, 78, 361,
		 397, 363, 74, 74, 78, 74, 74, 364, 74, 74,
		 397, 78, 74, 74, 74, 74, 78, 397, 78, 74,
		 74, 78, 365, 78, 74, 74, 74, 74, 78, 74,

		 74, 74, 74, 74, 74, 397, 78, 397, 366, 78,
		 397, 368, 78, 397, 367, 397, 78, 369, 78, 74,
		 74, 74, 74, 78, 397, 370, 397, 371, 78, 397,
		 78, 372, 397, 78, 397, 78, 397, 78, 74, 74,
		 397, 74, 74, 74, 74, 74, 74, 74, 74, 397,
		 373, 374, 397, 78, 397, 78, 397, 375, 74, 74,
		 74, 74, 74, 74, 397, 74, 74, 397, 377, 74,
		 74, 397, 78, 376, 378, 78, 397, 78, 397, 78,
		 397, 78, 379, 74, 74, 74, 74, 381, 74, 74,
		 74, 74, 78, 380, 78, 397, 78, 74, 74, 78,

		 74, 74, 397, 78, 74, 74, 384, 74, 74, 382,
		 397, 383, 397, 74, 74, 74, 74, 78, 397, 78,
		 74, 74, 78, 397, 78, 386, 397, 385, 74, 74,
		 387, 78, 74, 74, 78, 389, 74, 74, 78, 74,
		 74, 78, 397, 392, 74, 74, 390, 78, 397, 78,
		 397, 388, 74, 74, 78, 74, 74, 391, 397, 74,
		 74, 397, 78, 74, 74, 397, 78, 393, 74, 74,
		 78, 74, 74, 78, 397, 394, 397, 397, 78, 397,
		 397, 397, 397, 397, 397, 397, 78, 395, 397, 78,
		 397, 396, 397, 78, 397, 397, 397, 78, 397, 397,

		 397, 397, 78, 397, 397, 78, 51, 51, 51, 51,
		 51, 51, 55, 55, 55, 55, 55, 55, 75, 75,
		 75, 119, 397, 119, 119, 119, 119, 75, 75, 173,
		 173, 173, 173, 173, 5, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397

};

static yyconst short int yy_chk[1800] =
		{0,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		 1, 1, 1, 1, 3, 4, 10, 13, 17, 55,
		 17, 17, 17, 3, 4, 19, 402, 19, 19, 19,
		 20, 20, 20, 21, 26, 26, 23, 22, 21, 22,
		 22, 22, 13, 23, 71, 23, 23, 23, 24, 57,

		 24, 24, 24, 28, 28, 68, 30, 30, 31, 31,
		 54, 10, 32, 32, 55, 33, 33, 30, 34, 34,
		 35, 35, 59, 59, 32, 33, 32, 39, 39, 33,
		 68, 22, 30, 33, 36, 36, 32, 23, 37, 37,
		 30, 39, 31, 53, 35, 50, 32, 48, 37, 33,
		 34, 44, 34, 27, 35, 38, 38, 36, 36, 60,
		 60, 39, 37, 40, 40, 38, 42, 42, 36, 38,
		 45, 45, 37, 41, 41, 40, 40, 40, 12, 38,
		 42, 38, 9, 40, 40, 43, 43, 41, 50, 38,
		 42, 41, 40, 46, 46, 43, 5, 40, 0, 50,

		 42, 122, 122, 43, 45, 75, 75, 41, 45, 61,
		 61, 61, 62, 0, 62, 62, 62, 76, 76, 43,
		 63, 63, 63, 66, 66, 66, 0, 46, 77, 77,
		 81, 81, 63, 0, 46, 66, 79, 79, 0, 75,
		 80, 80, 83, 83, 76, 82, 82, 86, 86, 123,
		 123, 76, 0, 81, 77, 0, 63, 0, 0, 66,
		 79, 80, 77, 83, 81, 84, 84, 83, 86, 83,
		 79, 0, 83, 82, 80, 0, 83, 85, 85, 82,
		 84, 86, 87, 87, 89, 89, 0, 88, 88, 85,
		 90, 90, 91, 91, 87, 84, 92, 92, 0, 84,

		 0, 0, 90, 93, 93, 0, 89, 94, 94, 87,
		 87, 85, 88, 0, 96, 96, 87, 0, 89, 0,
		 91, 88, 92, 0, 90, 0, 91, 95, 95, 93,
		 92, 94, 97, 97, 98, 98, 0, 93, 96, 95,
		 0, 94, 99, 99, 100, 100, 0, 97, 96, 95,
		 101, 101, 102, 102, 100, 95, 99, 103, 103, 104,
		 104, 95, 98, 0, 106, 106, 97, 0, 98, 105,
		 105, 0, 101, 0, 102, 0, 99, 0, 100, 103,
		 109, 109, 104, 0, 101, 104, 102, 107, 107, 0,
		 105, 103, 0, 104, 106, 110, 110, 0, 106, 118,

		 107, 118, 0, 105, 118, 118, 118, 0, 120, 120,
		 120, 121, 0, 121, 109, 0, 121, 121, 121, 109,
		 120, 107, 125, 125, 126, 126, 0, 127, 127, 110,
		 128, 128, 0, 129, 129, 0, 130, 130, 110, 134,
		 134, 131, 131, 0, 120, 127, 139, 139, 126, 130,
		 132, 132, 0, 128, 129, 131, 125, 134, 126, 139,
		 132, 127, 133, 133, 128, 135, 135, 129, 137, 137,
		 130, 0, 133, 134, 0, 131, 136, 136, 138, 138,
		 139, 140, 140, 135, 132, 0, 137, 0, 141, 141,
		 0, 136, 138, 0, 142, 142, 133, 144, 144, 135,

		 145, 145, 137, 143, 143, 147, 147, 140, 142, 0,
		 136, 144, 138, 143, 0, 140, 141, 145, 146, 146,
		 148, 148, 141, 147, 149, 149, 151, 151, 142, 150,
		 150, 144, 152, 152, 145, 146, 149, 143, 0, 147,
		 149, 0, 152, 0, 153, 153, 154, 154, 148, 0,
		 151, 0, 146, 150, 148, 150, 155, 155, 149, 0,
		 151, 156, 156, 150, 158, 158, 152, 153, 0, 157,
		 157, 159, 159, 160, 160, 0, 154, 0, 153, 0,
		 154, 157, 162, 162, 0, 155, 0, 160, 161, 161,
		 155, 160, 156, 163, 163, 156, 159, 0, 158, 164,

		 164, 161, 0, 157, 0, 159, 0, 160, 0, 162,
		 165, 165, 0, 164, 166, 166, 162, 167, 167, 173,
		 173, 163, 161, 168, 168, 168, 0, 163, 169, 169,
		 169, 176, 176, 164, 170, 0, 170, 0, 165, 170,
		 170, 170, 175, 175, 165, 171, 171, 171, 166, 177,
		 177, 167, 166, 173, 0, 167, 172, 172, 172, 178,
		 178, 176, 177, 175, 0, 176, 179, 179, 180, 180,
		 181, 181, 182, 182, 183, 183, 175, 184, 184, 0,
		 179, 185, 185, 177, 186, 186, 0, 178, 0, 184,
		 183, 187, 187, 178, 188, 188, 0, 186, 182, 0,

		 179, 0, 180, 181, 181, 0, 182, 0, 183, 189,
		 189, 184, 190, 190, 0, 185, 187, 0, 186, 191,
		 191, 0, 190, 189, 0, 187, 192, 192, 188, 193,
		 193, 194, 194, 196, 196, 0, 195, 195, 197, 197,
		 0, 194, 0, 189, 0, 191, 190, 0, 195, 0,
		 198, 198, 0, 191, 192, 199, 199, 196, 200, 200,
		 192, 195, 0, 193, 198, 194, 0, 196, 201, 201,
		 195, 0, 197, 202, 202, 203, 203, 204, 204, 206,
		 206, 199, 201, 0, 198, 205, 205, 0, 200, 199,
		 204, 0, 200, 203, 207, 207, 208, 208, 0, 205,

		 209, 209, 201, 202, 206, 0, 207, 202, 0, 203,
		 0, 204, 0, 206, 209, 0, 208, 210, 210, 205,
		 211, 211, 212, 212, 213, 213, 214, 214, 207, 0,
		 208, 0, 215, 215, 209, 0, 214, 0, 216, 216,
		 217, 217, 213, 211, 210, 0, 212, 215, 218, 218,
		 0, 210, 221, 221, 211, 216, 212, 0, 213, 0,
		 214, 219, 219, 219, 223, 223, 215, 220, 220, 220,
		 222, 222, 216, 0, 217, 224, 224, 217, 225, 225,
		 222, 221, 218, 227, 227, 218, 221, 226, 226, 0,
		 228, 228, 229, 229, 231, 231, 230, 230, 223, 225,

		 233, 233, 226, 0, 222, 0, 229, 0, 224, 224,
		 230, 227, 225, 228, 232, 232, 0, 227, 0, 234,
		 234, 226, 231, 233, 228, 0, 229, 0, 231, 0,
		 230, 234, 235, 235, 233, 0, 232, 236, 236, 237,
		 237, 238, 238, 239, 239, 240, 240, 0, 232, 235,
		 0, 241, 241, 234, 242, 242, 239, 0, 243, 243,
		 236, 241, 0, 237, 244, 244, 235, 0, 242, 0,
		 238, 236, 240, 237, 244, 238, 0, 239, 0, 240,
		 243, 245, 245, 246, 246, 241, 247, 247, 242, 248,
		 248, 0, 243, 0, 249, 249, 250, 250, 244, 251,

		 251, 252, 252, 0, 245, 0, 248, 0, 253, 253,
		 254, 254, 247, 252, 0, 245, 0, 246, 249, 0,
		 247, 255, 255, 248, 253, 251, 257, 257, 249, 0,
		 250, 256, 256, 251, 0, 252, 254, 258, 258, 259,
		 259, 0, 253, 0, 254, 255, 0, 256, 260, 260,
		 257, 261, 261, 0, 0, 255, 262, 262, 263, 263,
		 257, 264, 264, 265, 265, 256, 0, 266, 266, 267,
		 267, 258, 0, 259, 268, 268, 0, 262, 259, 261,
		 0, 265, 260, 263, 0, 261, 0, 260, 264, 0,
		 262, 0, 263, 269, 269, 264, 266, 265, 270, 270,

		 0, 266, 0, 267, 271, 271, 273, 273, 268, 272,
		 272, 274, 274, 275, 275, 0, 270, 0, 271, 269,
		 0, 272, 0, 276, 276, 278, 278, 269, 0, 275,
		 273, 0, 270, 277, 277, 279, 279, 278, 271, 0,
		 273, 280, 280, 272, 0, 274, 276, 275, 281, 281,
		 282, 282, 283, 283, 277, 284, 284, 276, 0, 278,
		 285, 285, 279, 280, 286, 286, 0, 277, 0, 279,
		 287, 287, 0, 283, 281, 280, 291, 291, 0, 0,
		 288, 288, 281, 0, 282, 0, 283, 285, 286, 284,
		 288, 289, 289, 287, 285, 290, 290, 0, 286, 292,

		 292, 289, 293, 293, 287, 294, 294, 290, 0, 290,
		 291, 295, 295, 0, 288, 0, 293, 296, 296, 0,
		 297, 297, 292, 298, 298, 289, 299, 299, 0, 290,
		 0, 294, 0, 292, 297, 0, 293, 301, 301, 294,
		 299, 0, 300, 300, 0, 295, 302, 302, 0, 295,
		 0, 296, 303, 303, 297, 296, 300, 298, 301, 0,
		 299, 304, 304, 0, 305, 305, 0, 306, 306, 307,
		 307, 301, 302, 0, 308, 308, 300, 309, 309, 0,
		 302, 306, 310, 310, 0, 304, 303, 305, 308, 311,
		 311, 0, 307, 312, 312, 304, 313, 313, 305, 314,

		 314, 306, 0, 307, 309, 315, 315, 0, 308, 310,
		 0, 309, 0, 311, 318, 318, 310, 316, 316, 317,
		 317, 319, 319, 311, 320, 320, 0, 312, 323, 323,
		 313, 0, 314, 314, 0, 316, 0, 321, 321, 315,
		 317, 318, 322, 322, 0, 320, 324, 324, 318, 319,
		 0, 316, 0, 317, 321, 319, 325, 325, 320, 326,
		 326, 0, 323, 327, 327, 322, 328, 328, 329, 329,
		 0, 321, 330, 330, 331, 331, 322, 0, 325, 0,
		 324, 332, 332, 0, 333, 333, 334, 334, 331, 0,
		 325, 335, 335, 326, 0, 332, 0, 327, 336, 336,

		 328, 0, 329, 337, 337, 0, 330, 333, 331, 0,
		 338, 338, 339, 339, 334, 332, 340, 340, 333, 0,
		 334, 336, 341, 341, 0, 335, 339, 342, 342, 343,
		 343, 0, 336, 0, 344, 344, 0, 337, 338, 340,
		 345, 345, 343, 0, 338, 0, 339, 348, 348, 0,
		 340, 342, 346, 346, 349, 349, 341, 347, 347, 350,
		 350, 342, 344, 343, 351, 351, 346, 0, 344, 345,
		 0, 347, 352, 352, 345, 353, 353, 348, 354, 354,
		 0, 348, 355, 355, 357, 357, 346, 0, 349, 356,
		 356, 347, 354, 350, 358, 358, 359, 359, 351, 360,

		 360, 361, 361, 362, 362, 0, 352, 0, 355, 353,
		 0, 357, 354, 0, 356, 0, 355, 358, 357, 363,
		 363, 364, 364, 356, 0, 360, 0, 361, 358, 0,
		 359, 363, 0, 360, 0, 361, 0, 362, 365, 365,
		 0, 366, 366, 367, 367, 368, 368, 369, 369, 0,
		 365, 366, 0, 363, 0, 364, 0, 367, 370, 370,
		 371, 371, 372, 372, 0, 373, 373, 0, 370, 374,
		 374, 0, 365, 368, 371, 366, 0, 367, 0, 368,
		 0, 369, 372, 375, 375, 376, 376, 374, 377, 377,
		 378, 378, 370, 373, 371, 0, 372, 379, 379, 373,

		 380, 380, 0, 374, 381, 381, 377, 385, 385, 375,
		 0, 376, 0, 382, 382, 388, 388, 375, 0, 376,
		 383, 383, 377, 0, 378, 382, 0, 381, 384, 384,
		 383, 379, 386, 386, 380, 385, 389, 389, 381, 387,
		 387, 385, 0, 388, 390, 390, 386, 382, 0, 388,
		 0, 384, 391, 391, 383, 392, 392, 387, 0, 393,
		 393, 0, 384, 394, 394, 0, 386, 390, 395, 395,
		 389, 396, 396, 387, 0, 391, 0, 0, 390, 0,
		 0, 0, 0, 0, 0, 0, 391, 393, 0, 392,
		 0, 394, 0, 393, 0, 0, 0, 394, 0, 0,

		 0, 0, 395, 0, 0, 396, 398, 398, 398, 398,
		 398, 398, 399, 399, 399, 399, 399, 399, 400, 400,
		 400, 401, 0, 401, 401, 401, 401, 403, 403, 404,
		 404, 404, 405, 405, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
		 397, 397, 397, 397, 397, 397, 397, 397, 397

};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "src/sdf_file.l"
#define INITIAL 0
#line 2 "src/sdf_file.l"
// **************************************************************************
// File       [ sdf_file.l ]
// Author     [ littleshamoo ]
// Synopsis   [ Lex for reading SDF file 3.0 ]
// Date       [ 2010/11/18 created ]
// **************************************************************************

#include "sdf_file.h"
#include "sdf_file.tab.hpp"

using namespace std;

int sdf_fileline = 1;

#define YY_NO_UNPUT 1
#define COMMENT 1

#line 936 "lib/opt/lex_n_yacc/sdf_file.yy.cpp"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO((void));
#else
extern int yywrap YY_PROTO((void));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO((int c, char *buf_ptr));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO((char *, yyconst char *, int));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO((yyconst char *));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO((void));
#else
static int input YY_PROTO((void));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO((int new_state));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO((void));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO((void));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void)fwrite(yytext, yyleng, 1, yyout)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                   \
	if (yy_current_buffer->yy_is_interactive)                               \
	{                                                                       \
		int c = '*', n;                                                       \
		for (n = 0; n < max_size &&                                           \
								(c = getc(yyin)) != EOF && c != '\n';                     \
				 ++n)                                                             \
			buf[n] = (char)c;                                                   \
		if (c == '\n')                                                        \
			buf[n++] = (char)c;                                                 \
		if (c == EOF && ferror(yyin))                                         \
			YY_FATAL_ERROR("input in flex scanner failed");                     \
		result = n;                                                           \
	}                                                                       \
	else                                                                    \
	{                                                                       \
		errno = 0;                                                            \
		while ((result = fread(buf, 1, max_size, yyin)) == 0 && ferror(yyin)) \
		{                                                                     \
			if (errno != EINTR)                                                 \
			{                                                                   \
				YY_FATAL_ERROR("input in flex scanner failed");                   \
				break;                                                            \
			}                                                                   \
			errno = 0;                                                          \
			clearerr(yyin);                                                     \
		}                                                                     \
	}
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO((void))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;

#line 30 "src/sdf_file.l"

#line 1101 "lib/opt/lex_n_yacc/sdf_file.yy.cpp"

	if (yy_init)
	{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if (!yy_start)
			yy_start = 1; /* first start state */

		if (!yyin)
			yyin = stdin;

		if (!yyout)
			yyout = stdout;

		if (!yy_current_buffer)
			yy_current_buffer =
					yy_create_buffer(yyin, YY_BUF_SIZE);

		yy_load_buffer_state();
	}

	while (1) /* loops until end-of-file is reached */
	{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
	yy_match:
		do
		{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if (yy_accept[yy_current_state])
			{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
			}
			while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
			{
				yy_current_state = (int)yy_def[yy_current_state];
				if (yy_current_state >= 398)
					yy_c = yy_meta[(unsigned int)yy_c];
			}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
			++yy_cp;
		} while (yy_base[yy_current_state] != 1735);

	yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if (yy_act == 0)
		{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
		}

		YY_DO_BEFORE_ACTION;

	do_action: /* This label is used only to access EOF actions. */

		switch (yy_act)
		{					/* beginning of action switch */
			case 0: /* must back up */
				/* undo the effects of YY_DO_BEFORE_ACTION */
				*yy_cp = yy_hold_char;
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
				goto yy_find_action;

			case 1:
				YY_RULE_SETUP
#line 32 "src/sdf_file.l"
						;
				YY_BREAK
			case 2:
				YY_RULE_SETUP
#line 33 "src/sdf_file.l"
				BEGIN COMMENT;
				YY_BREAK
			case 3:
				YY_RULE_SETUP
#line 34 "src/sdf_file.l"
				BEGIN INITIAL;
				YY_BREAK
			case 4:
				YY_RULE_SETUP
#line 35 "src/sdf_file.l"
				{
					sdf_fileline++;
				}
				YY_BREAK
			case 5:
				YY_RULE_SETUP
#line 36 "src/sdf_file.l"

				YY_BREAK
			case 6:
				YY_RULE_SETUP
#line 38 "src/sdf_file.l"
				{
					return DELAYFILE;
				}
				YY_BREAK
			case 7:
				YY_RULE_SETUP
#line 39 "src/sdf_file.l"
				{
					return SDFVERSION;
				}
				YY_BREAK
			case 8:
				YY_RULE_SETUP
#line 40 "src/sdf_file.l"
				{
					return DESIGN;
				}
				YY_BREAK
			case 9:
				YY_RULE_SETUP
#line 41 "src/sdf_file.l"
				{
					return DATE;
				}
				YY_BREAK
			case 10:
				YY_RULE_SETUP
#line 42 "src/sdf_file.l"
				{
					return VENDOR;
				}
				YY_BREAK
			case 11:
				YY_RULE_SETUP
#line 43 "src/sdf_file.l"
				{
					return PROGRAM;
				}
				YY_BREAK
			case 12:
				YY_RULE_SETUP
#line 44 "src/sdf_file.l"
				{
					return VERSION;
				}
				YY_BREAK
			case 13:
				YY_RULE_SETUP
#line 45 "src/sdf_file.l"
				{
					return DIVIDER;
				}
				YY_BREAK
			case 14:
				YY_RULE_SETUP
#line 46 "src/sdf_file.l"
				{
					return VOLTAGE;
				}
				YY_BREAK
			case 15:
				YY_RULE_SETUP
#line 47 "src/sdf_file.l"
				{
					return PROCESS;
				}
				YY_BREAK
			case 16:
				YY_RULE_SETUP
#line 48 "src/sdf_file.l"
				{
					return TEMPERATURE;
				}
				YY_BREAK
			case 17:
				YY_RULE_SETUP
#line 49 "src/sdf_file.l"
				{
					return TIMESCALE;
				}
				YY_BREAK
			case 18:
				YY_RULE_SETUP
#line 50 "src/sdf_file.l"
				{
					return CELL;
				}
				YY_BREAK
			case 19:
				YY_RULE_SETUP
#line 51 "src/sdf_file.l"
				{
					return CELLTYPE;
				}
				YY_BREAK
			case 20:
				YY_RULE_SETUP
#line 52 "src/sdf_file.l"
				{
					return INSTANCE;
				}
				YY_BREAK
			case 21:
				YY_RULE_SETUP
#line 53 "src/sdf_file.l"
				{
					return DELAY;
				}
				YY_BREAK
			case 22:
				YY_RULE_SETUP
#line 54 "src/sdf_file.l"
				{
					return TIMINGCHECK;
				}
				YY_BREAK
			case 23:
				YY_RULE_SETUP
#line 55 "src/sdf_file.l"
				{
					return TIMINGENV;
				}
				YY_BREAK
			case 24:
				YY_RULE_SETUP
#line 56 "src/sdf_file.l"
				{
					return PATHPULSE;
				}
				YY_BREAK
			case 25:
				YY_RULE_SETUP
#line 57 "src/sdf_file.l"
				{
					return PATHPULSEPERCENT;
				}
				YY_BREAK
			case 26:
				YY_RULE_SETUP
#line 58 "src/sdf_file.l"
				{
					return ABSOLUTE;
				}
				YY_BREAK
			case 27:
				YY_RULE_SETUP
#line 59 "src/sdf_file.l"
				{
					return INCREMENT;
				}
				YY_BREAK
			case 28:
				YY_RULE_SETUP
#line 60 "src/sdf_file.l"
				{
					return IOPATH;
				}
				YY_BREAK
			case 29:
				YY_RULE_SETUP
#line 61 "src/sdf_file.l"
				{
					return RETAIN;
				}
				YY_BREAK
			case 30:
				YY_RULE_SETUP
#line 62 "src/sdf_file.l"
				{
					return COND;
				}
				YY_BREAK
			case 31:
				YY_RULE_SETUP
#line 63 "src/sdf_file.l"
				{
					return SCOND;
				}
				YY_BREAK
			case 32:
				YY_RULE_SETUP
#line 64 "src/sdf_file.l"
				{
					return CCOND;
				}
				YY_BREAK
			case 33:
				YY_RULE_SETUP
#line 65 "src/sdf_file.l"
				{
					return CONDELSE;
				}
				YY_BREAK
			case 34:
				YY_RULE_SETUP
#line 66 "src/sdf_file.l"
				{
					return PORT;
				}
				YY_BREAK
			case 35:
				YY_RULE_SETUP
#line 67 "src/sdf_file.l"
				{
					return INTERCONNECT;
				}
				YY_BREAK
			case 36:
				YY_RULE_SETUP
#line 68 "src/sdf_file.l"
				{
					return DEVICE;
				}
				YY_BREAK
			case 37:
				YY_RULE_SETUP
#line 69 "src/sdf_file.l"
				{
					return SETUP;
				}
				YY_BREAK
			case 38:
				YY_RULE_SETUP
#line 70 "src/sdf_file.l"
				{
					return HOLD;
				}
				YY_BREAK
			case 39:
				YY_RULE_SETUP
#line 71 "src/sdf_file.l"
				{
					return SETUPHOLD;
				}
				YY_BREAK
			case 40:
				YY_RULE_SETUP
#line 72 "src/sdf_file.l"
				{
					return RECOVERY;
				}
				YY_BREAK
			case 41:
				YY_RULE_SETUP
#line 73 "src/sdf_file.l"
				{
					return REMOVAL;
				}
				YY_BREAK
			case 42:
				YY_RULE_SETUP
#line 74 "src/sdf_file.l"
				{
					return RECREM;
				}
				YY_BREAK
			case 43:
				YY_RULE_SETUP
#line 75 "src/sdf_file.l"
				{
					return SKEW;
				}
				YY_BREAK
			case 44:
				YY_RULE_SETUP
#line 76 "src/sdf_file.l"
				{
					return WIDTH;
				}
				YY_BREAK
			case 45:
				YY_RULE_SETUP
#line 77 "src/sdf_file.l"
				{
					return PERIOD;
				}
				YY_BREAK
			case 46:
				YY_RULE_SETUP
#line 78 "src/sdf_file.l"
				{
					return NOCHANGE;
				}
				YY_BREAK
			case 47:
				YY_RULE_SETUP
#line 79 "src/sdf_file.l"
				{
					return NAME;
				}
				YY_BREAK
			case 48:
				YY_RULE_SETUP
#line 80 "src/sdf_file.l"
				{
					return EXCEPTION;
				}
				YY_BREAK
			case 49:
				YY_RULE_SETUP
#line 81 "src/sdf_file.l"
				{
					return PATHCONSTRAINT;
				}
				YY_BREAK
			case 50:
				YY_RULE_SETUP
#line 82 "src/sdf_file.l"
				{
					return PERIODCONSTRAINT;
				}
				YY_BREAK
			case 51:
				YY_RULE_SETUP
#line 83 "src/sdf_file.l"
				{
					return SUM;
				}
				YY_BREAK
			case 52:
				YY_RULE_SETUP
#line 84 "src/sdf_file.l"
				{
					return DIFF;
				}
				YY_BREAK
			case 53:
				YY_RULE_SETUP
#line 85 "src/sdf_file.l"
				{
					return SKEWCONSTRAINT;
				}
				YY_BREAK
			case 54:
				YY_RULE_SETUP
#line 86 "src/sdf_file.l"
				{
					return ARRIVAL;
				}
				YY_BREAK
			case 55:
				YY_RULE_SETUP
#line 87 "src/sdf_file.l"
				{
					return DEPARTURE;
				}
				YY_BREAK
			case 56:
				YY_RULE_SETUP
#line 88 "src/sdf_file.l"
				{
					return SLACK;
				}
				YY_BREAK
			case 57:
				YY_RULE_SETUP
#line 89 "src/sdf_file.l"
				{
					return WAVEFORM;
				}
				YY_BREAK
			case 58:
				YY_RULE_SETUP
#line 90 "src/sdf_file.l"
				{
					return POSEDGE;
				}
				YY_BREAK
			case 59:
				YY_RULE_SETUP
#line 91 "src/sdf_file.l"
				{
					return NEGEDGE;
				}
				YY_BREAK
			case 60:
				YY_RULE_SETUP
#line 93 "src/sdf_file.l"
				{
					strcpy(sdf_filelval.ychar, sdf_filetext);
					return QSTRING;
				}
				YY_BREAK
			case 61:
				YY_RULE_SETUP
#line 98 "src/sdf_file.l"
				{
					strcpy(sdf_filelval.ychar, sdf_filetext);
					return PATH;
				}
				YY_BREAK
			case 62:
				YY_RULE_SETUP
#line 103 "src/sdf_file.l"
				{
					strcpy(sdf_filelval.ychar, sdf_filetext);
					return BIT_CONST;
				}
				YY_BREAK
			case 63:
				YY_RULE_SETUP
#line 108 "src/sdf_file.l"
				{
					strcpy(sdf_filelval.ychar, sdf_filetext);
					return EDGE;
				}
				YY_BREAK
			case 64:
				YY_RULE_SETUP
#line 113 "src/sdf_file.l"
				{
					strcpy(sdf_filelval.ychar, sdf_filetext);
					return IDENTIFIER;
				}
				YY_BREAK
			case 65:
				YY_RULE_SETUP
#line 118 "src/sdf_file.l"
				{
					sdf_filelval.yfloat = atof(sdf_filetext);
					return NUMBER;
				}
				YY_BREAK
			case 66:
				YY_RULE_SETUP
#line 123 "src/sdf_file.l"
				{
					sdf_filelval.yfloat = atof(sdf_filetext);
					return NUMBER;
				}
				YY_BREAK
			case 67:
				YY_RULE_SETUP
#line 128 "src/sdf_file.l"
				{
					sdf_filelval.yfloat = atof(sdf_filetext);
					return NUMBER;
				}
				YY_BREAK
			case 68:
				YY_RULE_SETUP
#line 133 "src/sdf_file.l"
				{
					return CASE_EQU;
				}
				YY_BREAK
			case 69:
				YY_RULE_SETUP
#line 134 "src/sdf_file.l"
				{
					return CASE_INEQU;
				}
				YY_BREAK
			case 70:
				YY_RULE_SETUP
#line 135 "src/sdf_file.l"
				{
					return EQU;
				}
				YY_BREAK
			case 71:
				YY_RULE_SETUP
#line 136 "src/sdf_file.l"
				{
					return INEQU;
				}
				YY_BREAK
			case 72:
				YY_RULE_SETUP
#line 137 "src/sdf_file.l"
				{
					return L_AND;
				}
				YY_BREAK
			case 73:
				YY_RULE_SETUP
#line 138 "src/sdf_file.l"
				{
					return L_OR;
				}
				YY_BREAK
			case 74:
				YY_RULE_SETUP
#line 139 "src/sdf_file.l"
				{
					return LESS_OR_EQU;
				}
				YY_BREAK
			case 75:
				YY_RULE_SETUP
#line 140 "src/sdf_file.l"
				{
					return GREATER_OR_EQU;
				}
				YY_BREAK
			case 76:
				YY_RULE_SETUP
#line 141 "src/sdf_file.l"
				{
					return RIGHT_SHIFT;
				}
				YY_BREAK
			case 77:
				YY_RULE_SETUP
#line 142 "src/sdf_file.l"
				{
					return LEFT_SHIFT;
				}
				YY_BREAK
			case 78:
				YY_RULE_SETUP
#line 143 "src/sdf_file.l"
				{
					return U_NAND;
				}
				YY_BREAK
			case 79:
				YY_RULE_SETUP
#line 144 "src/sdf_file.l"
				{
					return U_NOR;
				}
				YY_BREAK
			case 80:
				YY_RULE_SETUP
#line 145 "src/sdf_file.l"
				{
					return U_XNOR;
				}
				YY_BREAK
			case 81:
				YY_RULE_SETUP
#line 146 "src/sdf_file.l"
				{
					return U_XNOR_ALT;
				}
				YY_BREAK
			case 82:
				YY_RULE_SETUP
#line 148 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 83:
				YY_RULE_SETUP
#line 149 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 84:
				YY_RULE_SETUP
#line 150 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 85:
				YY_RULE_SETUP
#line 151 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 86:
				YY_RULE_SETUP
#line 152 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 87:
				YY_RULE_SETUP
#line 153 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 88:
				YY_RULE_SETUP
#line 154 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 89:
				YY_RULE_SETUP
#line 155 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 90:
				YY_RULE_SETUP
#line 156 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 91:
				YY_RULE_SETUP
#line 157 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 92:
				YY_RULE_SETUP
#line 158 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 93:
				YY_RULE_SETUP
#line 159 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 94:
				YY_RULE_SETUP
#line 160 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 95:
				YY_RULE_SETUP
#line 161 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 96:
				YY_RULE_SETUP
#line 162 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 97:
				YY_RULE_SETUP
#line 163 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 98:
				YY_RULE_SETUP
#line 164 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 99:
				YY_RULE_SETUP
#line 165 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 100:
				YY_RULE_SETUP
#line 166 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 101:
				YY_RULE_SETUP
#line 167 "src/sdf_file.l"
				{
					return sdf_filetext[0];
				}
				YY_BREAK
			case 102:
				YY_RULE_SETUP
#line 169 "src/sdf_file.l"
				{
					sdf_fileline++;
				}
				YY_BREAK
			case 103:
				YY_RULE_SETUP
#line 170 "src/sdf_file.l"
						;
				YY_BREAK
			case 104:
				YY_RULE_SETUP
#line 171 "src/sdf_file.l"
						;
				YY_BREAK
			case 105:
				YY_RULE_SETUP
#line 173 "src/sdf_file.l"
				ECHO;
				YY_BREAK
#line 1733 "lib/opt/lex_n_yacc/sdf_file.yy.cpp"
			case YY_STATE_EOF(INITIAL):
			case YY_STATE_EOF(COMMENT):
				yyterminate();

			case YY_END_OF_BUFFER:
			{
				/* Amount of text matched not including the EOB char. */
				int yy_amount_of_matched_text = (int)(yy_cp - yytext_ptr) - 1;

				/* Undo the effects of YY_DO_BEFORE_ACTION. */
				*yy_cp = yy_hold_char;
				YY_RESTORE_YY_MORE_OFFSET

				if (yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW)
				{
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between yy_current_buffer and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					yy_n_chars = yy_current_buffer->yy_n_chars;
					yy_current_buffer->yy_input_file = yyin;
					yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
				}

				/* Note that here we test for yy_c_buf_p "<=" to the position
				 * of the first EOB in the buffer, since yy_c_buf_p will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if (yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars])
				{ /* This was really a NUL. */
					yy_state_type yy_next_state;

					yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

					yy_current_state = yy_get_previous_state();

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yy_get_previous_state() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yy_next_state = yy_try_NUL_trans(yy_current_state);

					yy_bp = yytext_ptr + YY_MORE_ADJ;

					if (yy_next_state)
					{
						/* Consume the NUL. */
						yy_cp = ++yy_c_buf_p;
						yy_current_state = yy_next_state;
						goto yy_match;
					}

					else
					{
						yy_cp = yy_c_buf_p;
						goto yy_find_action;
					}
				}

				else
					switch (yy_get_next_buffer())
					{
						case EOB_ACT_END_OF_FILE:
						{
							yy_did_buffer_switch_on_eof = 0;

							if (yywrap())
							{
								/* Note: because we've taken care in
								 * yy_get_next_buffer() to have set up
								 * yytext, we can now set up
								 * yy_c_buf_p so that if some total
								 * hoser (like flex itself) wants to
								 * call the scanner after we return the
								 * YY_NULL, it'll still work - another
								 * YY_NULL will get returned.
								 */
								yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

								yy_act = YY_STATE_EOF(YY_START);
								goto do_action;
							}

							else
							{
								if (!yy_did_buffer_switch_on_eof)
									YY_NEW_FILE;
							}
							break;
						}

						case EOB_ACT_CONTINUE_SCAN:
							yy_c_buf_p =
									yytext_ptr + yy_amount_of_matched_text;

							yy_current_state = yy_get_previous_state();

							yy_cp = yy_c_buf_p;
							yy_bp = yytext_ptr + YY_MORE_ADJ;
							goto yy_match;

						case EOB_ACT_LAST_MATCH:
							yy_c_buf_p =
									&yy_current_buffer->yy_ch_buf[yy_n_chars];

							yy_current_state = yy_get_previous_state();

							yy_cp = yy_c_buf_p;
							yy_bp = yytext_ptr + YY_MORE_ADJ;
							goto yy_find_action;
					}
				break;
			}

			default:
				YY_FATAL_ERROR(
						"fatal flex scanner internal error--no action found");
		} /* end of action switch */
	}		/* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if (yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1])
		YY_FATAL_ERROR(
				"fatal flex scanner internal error--end of buffer missed");

	if (yy_current_buffer->yy_fill_buffer == 0)
	{ /* Don't try to fill the buffer, so this is an EOF. */
		if (yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1)
		{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
		}

		else
		{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
		}
	}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int)(yy_c_buf_p - yytext_ptr) - 1;

	for (i = 0; i < number_to_move; ++i)
		*(dest++) = *(source++);

	if (yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING)
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_current_buffer->yy_n_chars = yy_n_chars = 0;

	else
	{
		int num_to_read =
				yy_current_buffer->yy_buf_size - number_to_move - 1;

		while (num_to_read <= 0)
		{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
					"input buffer overflow, can't enlarge buffer because scanner uses REJECT");
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
					(int)(yy_c_buf_p - b->yy_ch_buf);

			if (b->yy_is_our_buffer)
			{
				int new_size = b->yy_buf_size * 2;

				if (new_size <= 0)
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
						/* Include room in for 2 EOB chars. */
						yy_flex_realloc((void *)b->yy_ch_buf,
														b->yy_buf_size + 2);
			}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if (!b->yy_ch_buf)
				YY_FATAL_ERROR(
						"fatal error - scanner input buffer overflow");

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
										number_to_move - 1;
#endif
		}

		if (num_to_read > YY_READ_BUF_SIZE)
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT((&yy_current_buffer->yy_ch_buf[number_to_move]),
						 yy_n_chars, num_to_read);

		yy_current_buffer->yy_n_chars = yy_n_chars;
	}

	if (yy_n_chars == 0)
	{
		if (number_to_move == YY_MORE_ADJ)
		{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin);
		}

		else
		{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
					YY_BUFFER_EOF_PENDING;
		}
	}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for (yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp)
	{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if (yy_accept[yy_current_state])
		{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
		}
		while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
		{
			yy_current_state = (int)yy_def[yy_current_state];
			if (yy_current_state >= 398)
				yy_c = yy_meta[(unsigned int)yy_c];
		}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
	}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
#else
static yy_state_type yy_try_NUL_trans(yy_current_state)
yy_state_type yy_current_state;
#endif
{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if (yy_accept[yy_current_state])
	{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
	}
	while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
	{
		yy_current_state = (int)yy_def[yy_current_state];
		if (yy_current_state >= 398)
			yy_c = yy_meta[(unsigned int)yy_c];
	}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
	yy_is_jam = (yy_current_state == 397);

	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput(int c, register char *yy_bp)
#else
static void yyunput(c, yy_bp) int c;
register char *yy_bp;
#endif
{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if (yy_cp < yy_current_buffer->yy_ch_buf + 2)
	{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while (source > yy_current_buffer->yy_ch_buf)
			*--dest = *--source;

		yy_cp += (int)(dest - source);
		yy_bp += (int)(dest - source);
		yy_current_buffer->yy_n_chars =
				yy_n_chars = yy_current_buffer->yy_buf_size;

		if (yy_cp < yy_current_buffer->yy_ch_buf + 2)
			YY_FATAL_ERROR("flex scanner push-back overflow");
	}

	*--yy_cp = (char)c;

	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
}
#endif /* ifndef YY_NO_UNPUT */

#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR)
	{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if (yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars])
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
		{ /* need more input */
			int offset = yy_c_buf_p - yytext_ptr;
			++yy_c_buf_p;

			switch (yy_get_next_buffer())
			{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin);

					/* fall through */

				case EOB_ACT_END_OF_FILE:
				{
					if (yywrap())
						return EOF;

					if (!yy_did_buffer_switch_on_eof)
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
				}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + offset;
					break;
			}
		}
	}

	c = *(unsigned char *)yy_c_buf_p; /* cast for 8-bit char's */
	*yy_c_buf_p = '\0';								/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;

	return c;
}

#ifdef YY_USE_PROTOS
void yyrestart(FILE *input_file)
#else
void yyrestart(input_file)
		FILE *input_file;
#endif
{
	if (!yy_current_buffer)
		yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);

	yy_init_buffer(yy_current_buffer, input_file);
	yy_load_buffer_state();
}

#ifdef YY_USE_PROTOS
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
#else
void yy_switch_to_buffer(new_buffer)
		YY_BUFFER_STATE new_buffer;
#endif
{
	if (yy_current_buffer == new_buffer)
		return;

	if (yy_current_buffer)
	{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
	}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
}

#ifdef YY_USE_PROTOS
void yy_load_buffer_state(void)
#else
void yy_load_buffer_state()
#endif
{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
}

#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size)
#else
YY_BUFFER_STATE yy_create_buffer(file, size)
FILE *file;
int size;
#endif
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE)yy_flex_alloc(sizeof(struct yy_buffer_state));
	if (!b)
		YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *)yy_flex_alloc(b->yy_buf_size + 2);
	if (!b->yy_ch_buf)
		YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b, file);

	return b;
}

#ifdef YY_USE_PROTOS
void yy_delete_buffer(YY_BUFFER_STATE b)
#else
void yy_delete_buffer(b)
		YY_BUFFER_STATE b;
#endif
{
	if (!b)
		return;

	if (b == yy_current_buffer)
		yy_current_buffer = (YY_BUFFER_STATE)0;

	if (b->yy_is_our_buffer)
		yy_flex_free((void *)b->yy_ch_buf);

	yy_flex_free((void *)b);
}

#ifndef _WIN32
#include <unistd.h>
#else
#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO((int));
#endif
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer(YY_BUFFER_STATE b, FILE *file)
#else
void yy_init_buffer(b, file)
		YY_BUFFER_STATE b;
FILE *file;
#endif

{
	yy_flush_buffer(b);

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;
#endif
#endif
}

#ifdef YY_USE_PROTOS
void yy_flush_buffer(YY_BUFFER_STATE b)
#else
void yy_flush_buffer(b)
		YY_BUFFER_STATE b;
#endif

{
	if (!b)
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if (b == yy_current_buffer)
		yy_load_buffer_state();
}

#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size)
#else
YY_BUFFER_STATE yy_scan_buffer(base, size)
char *base;
yy_size_t size;
#endif
{
	YY_BUFFER_STATE b;

	if (size < 2 ||
			base[size - 2] != YY_END_OF_BUFFER_CHAR ||
			base[size - 1] != YY_END_OF_BUFFER_CHAR)
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE)yy_flex_alloc(sizeof(struct yy_buffer_state));
	if (!b)
		YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

	b->yy_buf_size = size - 2; /* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer(b);

	return b;
}
#endif

#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string(yyconst char *yy_str)
#else
YY_BUFFER_STATE yy_scan_string(yy_str)
yyconst char *yy_str;
#endif
{
	int len;
	for (len = 0; yy_str[len]; ++len)
		;

	return yy_scan_bytes(yy_str, len);
}
#endif

#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes(yyconst char *bytes, int len)
#else
YY_BUFFER_STATE yy_scan_bytes(bytes, len)
yyconst char *bytes;
int len;
#endif
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *)yy_flex_alloc(n);
	if (!buf)
		YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

	for (i = 0; i < len; ++i)
		buf[i] = bytes[i];

	buf[len] = buf[len + 1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer(buf, n);
	if (!b)
		YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}
#endif

#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state(int new_state)
#else
static void yy_push_state(new_state) int new_state;
#endif
{
	if (yy_start_stack_ptr >= yy_start_stack_depth)
	{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof(int);

		if (!yy_start_stack)
			yy_start_stack = (int *)yy_flex_alloc(new_size);

		else
			yy_start_stack = (int *)yy_flex_realloc(
					(void *)yy_start_stack, new_size);

		if (!yy_start_stack)
			YY_FATAL_ERROR(
					"out of memory expanding start-condition stack");
	}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
}
#endif

#ifndef YY_NO_POP_STATE
static void yy_pop_state()
{
	if (--yy_start_stack_ptr < 0)
		YY_FATAL_ERROR("start-condition stack underflow");

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
}
#endif

#ifndef YY_NO_TOP_STATE
static int yy_top_state()
{
	return yy_start_stack[yy_start_stack_ptr - 1];
}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error(yyconst char msg[])
#else
static void yy_fatal_error(msg) char msg[];
#endif
{
	(void)fprintf(stderr, "%s\n", msg);
	exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                            \
	do                                         \
	{                                          \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char;           \
		yy_c_buf_p = yytext + n;                 \
		yy_hold_char = *yy_c_buf_p;              \
		*yy_c_buf_p = '\0';                      \
		yyleng = n;                              \
	} while (0)

/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy(char *s1, yyconst char *s2, int n)
#else
static void yy_flex_strncpy(s1, s2, n) char *s1;
yyconst char *s2;
int n;
#endif
{
	register int i;
	for (i = 0; i < n; ++i)
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen(yyconst char *s)
#else
static int yy_flex_strlen(s)
yyconst char *s;
#endif
{
	register int n;
	for (n = 0; s[n]; ++n)
		;

	return n;
}
#endif

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc(yy_size_t size)
#else
static void *yy_flex_alloc(size)
yy_size_t size;
#endif
{
	return (void *)malloc(size);
}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc(void *ptr, yy_size_t size)
#else
static void *yy_flex_realloc(ptr, size) void *ptr;
yy_size_t size;
#endif
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *)realloc((char *)ptr, size);
}

#ifdef YY_USE_PROTOS
static void yy_flex_free(void *ptr)
#else
static void yy_flex_free(ptr) void *ptr;
#endif
{
	free(ptr);
}

#if YY_MAIN
int main()
{
	yylex();
	return 0;
}
#endif
#line 173 "src/sdf_file.l"
